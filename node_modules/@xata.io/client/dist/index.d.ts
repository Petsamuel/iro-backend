interface CacheImpl {
    defaultQueryTTL: number;
    getAll(): Promise<Record<string, unknown>>;
    get: <T>(key: string) => Promise<T | null>;
    set: <T>(key: string, value: T) => Promise<void>;
    delete: (key: string) => Promise<void>;
    clear: () => Promise<void>;
}
interface SimpleCacheOptions {
    max?: number;
    defaultQueryTTL?: number;
}
declare class SimpleCache implements CacheImpl {
    #private;
    capacity: number;
    defaultQueryTTL: number;
    constructor(options?: SimpleCacheOptions);
    getAll(): Promise<Record<string, unknown>>;
    get<T>(key: string): Promise<T | null>;
    set<T>(key: string, value: T): Promise<void>;
    delete(key: string): Promise<void>;
    clear(): Promise<void>;
}

declare type AttributeDictionary = Record<string, string | number | boolean | undefined>;
declare type TraceFunction = <T>(name: string, fn: (options: {
    setAttributes: (attrs: AttributeDictionary) => void;
}) => T, options?: AttributeDictionary) => Promise<T>;

declare abstract class XataPlugin {
    abstract build(options: XataPluginOptions): unknown | Promise<unknown>;
}
declare type XataPluginOptions = {
    getFetchProps: () => Promise<ApiExtraProps>;
    cache: CacheImpl;
    trace?: TraceFunction;
};

declare type FetchImpl = (url: string, init?: {
    body?: string;
    headers?: Record<string, string>;
    method?: string;
    signal?: any;
}) => Promise<{
    ok: boolean;
    status: number;
    url: string;
    json(): Promise<any>;
    headers?: {
        get(name: string): string | null;
    };
}>;
declare type WorkspaceApiUrlBuilder = (path: string, pathParams: Partial<Record<string, string | number>>) => string;
declare type FetcherExtraProps = {
    endpoint: 'controlPlane' | 'dataPlane';
    apiUrl: string;
    workspacesApiUrl: string | WorkspaceApiUrlBuilder;
    fetchImpl: FetchImpl;
    apiKey: string;
    trace: TraceFunction;
    signal?: AbortSignal;
    clientID?: string;
    sessionID?: string;
    fetchOptions?: Record<string, unknown>;
};

declare type ControlPlaneFetcherExtraProps = {
    apiUrl: string;
    workspacesApiUrl: string | WorkspaceApiUrlBuilder;
    fetchImpl: FetchImpl;
    apiKey: string;
    trace: TraceFunction;
    signal?: AbortSignal;
    clientID?: string;
    sessionID?: string;
};
declare type ErrorWrapper$1<TError> = TError | {
    status: 'unknown';
    payload: string;
};

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
declare type User = {
    /**
     * @format email
     */
    email: string;
    fullname: string;
    image: string;
};
/**
 * @pattern [a-zA-Z0-9_-~:]+
 */
declare type UserID = string;
declare type UserWithID = User & {
    id: UserID;
};
/**
 * @format date-time
 * @x-go-type string
 */
declare type DateTime$1 = string;
/**
 * @pattern [a-zA-Z0-9_\-~]*
 */
declare type APIKeyName = string;
/**
 * @pattern ^([a-zA-Z0-9][a-zA-Z0-9_\-~]+-)?[a-zA-Z0-9]{6}
 * @x-go-type auth.WorkspaceID
 */
declare type WorkspaceID = string;
/**
 * @x-go-type auth.Role
 */
declare type Role = 'owner' | 'maintainer';
declare type WorkspaceMeta = {
    name: string;
    slug?: string;
};
declare type Workspace = WorkspaceMeta & {
    id: WorkspaceID;
    memberCount: number;
    plan: 'free' | 'pro';
};
declare type WorkspaceMember = {
    userId: UserID;
    fullname: string;
    /**
     * @format email
     */
    email: string;
    role: Role;
};
/**
 * @pattern [a-zA-Z0-9]+
 */
declare type InviteID = string;
declare type WorkspaceInvite = {
    inviteId: InviteID;
    /**
     * @format email
     */
    email: string;
    /**
     * @format date-time
     */
    expires: string;
    role: Role;
};
declare type WorkspaceMembers = {
    members: WorkspaceMember[];
    invites: WorkspaceInvite[];
};
/**
 * @pattern ^ik_[a-zA-Z0-9]+
 */
declare type InviteKey = string;
/**
 * Metadata of databases
 */
declare type DatabaseMetadata = {
    /**
     * The machine-readable name of a database
     */
    name: string;
    /**
     * Region where this database is hosted
     */
    region: string;
    /**
     * The time this database was created
     */
    createdAt: DateTime$1;
    /**
     * Metadata about the database for display in Xata user interfaces
     */
    ui?: {
        /**
         * The user-selected color for this database across interfaces
         */
        color?: string;
    };
};
declare type ListDatabasesResponse = {
    /**
     * A list of databases in a Xata workspace
     */
    databases: DatabaseMetadata[];
};
/**
 * @example {"repository":"github.com/my/repository","branch":"feature-login","stage":"testing","labels":["epic-100"]}
 * @x-go-type xata.BranchMetadata
 */
declare type BranchMetadata$1 = {
    /**
     * @minLength 1
     */
    repository?: string;
    branch?: BranchName$1;
    /**
     * @minLength 1
     */
    stage?: string;
    labels?: string[];
};
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type BranchName$1 = string;
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type DBName$1 = string;
declare type MigrationStatus$1 = 'completed' | 'pending' | 'failed';
declare type ListRegionsResponse = {
    /**
     * A list of regions where databases can be created
     */
    regions: Region[];
};
declare type Region = {
    id: string;
};

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
declare type SimpleError$1 = {
    id?: string;
    message: string;
};
declare type BadRequestError$1 = {
    id?: string;
    message: string;
};
/**
 * @example {"message":"invalid API key"}
 */
declare type AuthError$1 = {
    id?: string;
    message: string;
};

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */

declare type GetUserError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type GetUserVariables = ControlPlaneFetcherExtraProps;
/**
 * Return details of the user making the request
 */
declare const getUser: (variables: GetUserVariables, signal?: AbortSignal) => Promise<UserWithID>;
declare type UpdateUserError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type UpdateUserVariables = {
    body: User;
} & ControlPlaneFetcherExtraProps;
/**
 * Update user info
 */
declare const updateUser: (variables: UpdateUserVariables, signal?: AbortSignal) => Promise<UserWithID>;
declare type DeleteUserError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type DeleteUserVariables = ControlPlaneFetcherExtraProps;
/**
 * Delete the user making the request
 */
declare const deleteUser: (variables: DeleteUserVariables, signal?: AbortSignal) => Promise<undefined>;
declare type GetUserAPIKeysError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type GetUserAPIKeysResponse = {
    keys: {
        name: string;
        createdAt: DateTime$1;
    }[];
};
declare type GetUserAPIKeysVariables = ControlPlaneFetcherExtraProps;
/**
 * Retrieve a list of existing user API keys
 */
declare const getUserAPIKeys: (variables: GetUserAPIKeysVariables, signal?: AbortSignal) => Promise<GetUserAPIKeysResponse>;
declare type CreateUserAPIKeyPathParams = {
    /**
     * API Key name
     */
    keyName: APIKeyName;
};
declare type CreateUserAPIKeyError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type CreateUserAPIKeyResponse = {
    name: string;
    key: string;
    createdAt: DateTime$1;
};
declare type CreateUserAPIKeyVariables = {
    pathParams: CreateUserAPIKeyPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Create and return new API key
 */
declare const createUserAPIKey: (variables: CreateUserAPIKeyVariables, signal?: AbortSignal) => Promise<CreateUserAPIKeyResponse>;
declare type DeleteUserAPIKeyPathParams = {
    /**
     * API Key name
     */
    keyName: APIKeyName;
};
declare type DeleteUserAPIKeyError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type DeleteUserAPIKeyVariables = {
    pathParams: DeleteUserAPIKeyPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Delete an existing API key
 */
declare const deleteUserAPIKey: (variables: DeleteUserAPIKeyVariables, signal?: AbortSignal) => Promise<undefined>;
declare type GetWorkspacesListError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type GetWorkspacesListResponse = {
    workspaces: {
        id: WorkspaceID;
        name: string;
        slug: string;
        role: Role;
    }[];
};
declare type GetWorkspacesListVariables = ControlPlaneFetcherExtraProps;
/**
 * Retrieve the list of workspaces the user belongs to
 */
declare const getWorkspacesList: (variables: GetWorkspacesListVariables, signal?: AbortSignal) => Promise<GetWorkspacesListResponse>;
declare type CreateWorkspaceError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type CreateWorkspaceVariables = {
    body: WorkspaceMeta;
} & ControlPlaneFetcherExtraProps;
/**
 * Creates a new workspace with the user requesting it as its single owner.
 */
declare const createWorkspace: (variables: CreateWorkspaceVariables, signal?: AbortSignal) => Promise<Workspace>;
declare type GetWorkspacePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type GetWorkspaceError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type GetWorkspaceVariables = {
    pathParams: GetWorkspacePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Retrieve workspace info from a workspace ID
 */
declare const getWorkspace: (variables: GetWorkspaceVariables, signal?: AbortSignal) => Promise<Workspace>;
declare type UpdateWorkspacePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type UpdateWorkspaceError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type UpdateWorkspaceVariables = {
    body: WorkspaceMeta;
    pathParams: UpdateWorkspacePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Update workspace info
 */
declare const updateWorkspace: (variables: UpdateWorkspaceVariables, signal?: AbortSignal) => Promise<Workspace>;
declare type DeleteWorkspacePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type DeleteWorkspaceError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type DeleteWorkspaceVariables = {
    pathParams: DeleteWorkspacePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Delete the workspace with the provided ID
 */
declare const deleteWorkspace: (variables: DeleteWorkspaceVariables, signal?: AbortSignal) => Promise<undefined>;
declare type GetWorkspaceMembersListPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type GetWorkspaceMembersListError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type GetWorkspaceMembersListVariables = {
    pathParams: GetWorkspaceMembersListPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Retrieve the list of members of the given workspace
 */
declare const getWorkspaceMembersList: (variables: GetWorkspaceMembersListVariables, signal?: AbortSignal) => Promise<WorkspaceMembers>;
declare type UpdateWorkspaceMemberRolePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * UserID
     */
    userId: UserID;
};
declare type UpdateWorkspaceMemberRoleError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type UpdateWorkspaceMemberRoleRequestBody = {
    role: Role;
};
declare type UpdateWorkspaceMemberRoleVariables = {
    body: UpdateWorkspaceMemberRoleRequestBody;
    pathParams: UpdateWorkspaceMemberRolePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Update a workspace member role. Workspaces must always have at least one owner, so this operation will fail if trying to remove owner role from the last owner in the workspace.
 */
declare const updateWorkspaceMemberRole: (variables: UpdateWorkspaceMemberRoleVariables, signal?: AbortSignal) => Promise<undefined>;
declare type RemoveWorkspaceMemberPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * UserID
     */
    userId: UserID;
};
declare type RemoveWorkspaceMemberError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type RemoveWorkspaceMemberVariables = {
    pathParams: RemoveWorkspaceMemberPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Remove the member from the workspace
 */
declare const removeWorkspaceMember: (variables: RemoveWorkspaceMemberVariables, signal?: AbortSignal) => Promise<undefined>;
declare type InviteWorkspaceMemberPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type InviteWorkspaceMemberError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
} | {
    status: 409;
    payload: SimpleError$1;
}>;
declare type InviteWorkspaceMemberRequestBody = {
    /**
     * @format email
     */
    email: string;
    role: Role;
};
declare type InviteWorkspaceMemberVariables = {
    body: InviteWorkspaceMemberRequestBody;
    pathParams: InviteWorkspaceMemberPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Invite some user to join the workspace with the given role
 */
declare const inviteWorkspaceMember: (variables: InviteWorkspaceMemberVariables, signal?: AbortSignal) => Promise<WorkspaceInvite>;
declare type UpdateWorkspaceMemberInvitePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * Invite identifier
     */
    inviteId: InviteID;
};
declare type UpdateWorkspaceMemberInviteError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
} | {
    status: 422;
    payload: SimpleError$1;
}>;
declare type UpdateWorkspaceMemberInviteRequestBody = {
    role: Role;
};
declare type UpdateWorkspaceMemberInviteVariables = {
    body: UpdateWorkspaceMemberInviteRequestBody;
    pathParams: UpdateWorkspaceMemberInvitePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * This operation provides a way to update an existing invite. Updates are performed in-place; they do not change the invite link, the expiry time, nor do they re-notify the recipient of the invite.
 */
declare const updateWorkspaceMemberInvite: (variables: UpdateWorkspaceMemberInviteVariables, signal?: AbortSignal) => Promise<WorkspaceInvite>;
declare type CancelWorkspaceMemberInvitePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * Invite identifier
     */
    inviteId: InviteID;
};
declare type CancelWorkspaceMemberInviteError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type CancelWorkspaceMemberInviteVariables = {
    pathParams: CancelWorkspaceMemberInvitePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * This operation provides a way to cancel invites by deleting them. Already accepted invites cannot be deleted.
 */
declare const cancelWorkspaceMemberInvite: (variables: CancelWorkspaceMemberInviteVariables, signal?: AbortSignal) => Promise<undefined>;
declare type AcceptWorkspaceMemberInvitePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * Invite Key (secret) for the invited user
     */
    inviteKey: InviteKey;
};
declare type AcceptWorkspaceMemberInviteError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type AcceptWorkspaceMemberInviteVariables = {
    pathParams: AcceptWorkspaceMemberInvitePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Accept the invitation to join a workspace. If the operation succeeds the user will be a member of the workspace
 */
declare const acceptWorkspaceMemberInvite: (variables: AcceptWorkspaceMemberInviteVariables, signal?: AbortSignal) => Promise<undefined>;
declare type ResendWorkspaceMemberInvitePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * Invite identifier
     */
    inviteId: InviteID;
};
declare type ResendWorkspaceMemberInviteError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type ResendWorkspaceMemberInviteVariables = {
    pathParams: ResendWorkspaceMemberInvitePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * This operation provides a way to resend an Invite notification. Invite notifications can only be sent for Invites not yet accepted.
 */
declare const resendWorkspaceMemberInvite: (variables: ResendWorkspaceMemberInviteVariables, signal?: AbortSignal) => Promise<undefined>;
declare type GetDatabaseListPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type GetDatabaseListError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
}>;
declare type GetDatabaseListVariables = {
    pathParams: GetDatabaseListPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * List all databases available in your Workspace.
 */
declare const getDatabaseList: (variables: GetDatabaseListVariables, signal?: AbortSignal) => Promise<ListDatabasesResponse>;
declare type CreateDatabasePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * The Database Name
     */
    dbName: DBName$1;
};
declare type CreateDatabaseError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
}>;
declare type CreateDatabaseResponse = {
    /**
     * @minLength 1
     */
    databaseName: string;
    branchName?: string;
    status: MigrationStatus$1;
};
declare type CreateDatabaseRequestBody = {
    /**
     * @minLength 1
     */
    branchName?: string;
    /**
     * @minLength 1
     */
    region: string;
    ui?: {
        color?: string;
    };
    metadata?: BranchMetadata$1;
};
declare type CreateDatabaseVariables = {
    body: CreateDatabaseRequestBody;
    pathParams: CreateDatabasePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Create Database with identifier name
 */
declare const createDatabase: (variables: CreateDatabaseVariables, signal?: AbortSignal) => Promise<CreateDatabaseResponse>;
declare type DeleteDatabasePathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * The Database Name
     */
    dbName: DBName$1;
};
declare type DeleteDatabaseError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type DeleteDatabaseResponse = {
    status: MigrationStatus$1;
};
declare type DeleteDatabaseVariables = {
    pathParams: DeleteDatabasePathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Delete a database and all of its branches and tables permanently.
 */
declare const deleteDatabase: (variables: DeleteDatabaseVariables, signal?: AbortSignal) => Promise<DeleteDatabaseResponse>;
declare type GetDatabaseMetadataPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * The Database Name
     */
    dbName: DBName$1;
};
declare type GetDatabaseMetadataError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type GetDatabaseMetadataVariables = {
    pathParams: GetDatabaseMetadataPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Retrieve metadata of the given database
 */
declare const getDatabaseMetadata: (variables: GetDatabaseMetadataVariables, signal?: AbortSignal) => Promise<DatabaseMetadata>;
declare type UpdateDatabaseMetadataPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
    /**
     * The Database Name
     */
    dbName: DBName$1;
};
declare type UpdateDatabaseMetadataError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
} | {
    status: 404;
    payload: SimpleError$1;
}>;
declare type UpdateDatabaseMetadataRequestBody = {
    ui?: {
        /**
         * @minLength 1
         */
        color?: string;
    };
};
declare type UpdateDatabaseMetadataVariables = {
    body?: UpdateDatabaseMetadataRequestBody;
    pathParams: UpdateDatabaseMetadataPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * Update the color of the selected database
 */
declare const updateDatabaseMetadata: (variables: UpdateDatabaseMetadataVariables, signal?: AbortSignal) => Promise<DatabaseMetadata>;
declare type ListRegionsPathParams = {
    /**
     * Workspace ID
     */
    workspaceId: WorkspaceID;
};
declare type ListRegionsError = ErrorWrapper$1<{
    status: 400;
    payload: BadRequestError$1;
} | {
    status: 401;
    payload: AuthError$1;
}>;
declare type ListRegionsVariables = {
    pathParams: ListRegionsPathParams;
} & ControlPlaneFetcherExtraProps;
/**
 * List regions available to create a database on
 */
declare const listRegions: (variables: ListRegionsVariables, signal?: AbortSignal) => Promise<ListRegionsResponse>;

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */
/**
 * Metadata of databases
 */
declare type DEPRECATEDDatabaseMetadata = {
    /**
     * The machine-readable name of a database
     */
    name: string;
    /**
     * The time this database was created
     */
    createdAt: DateTime;
    /**
     * The number of branches the database has
     */
    numberOfBranches: number;
    /**
     * Metadata about the database for display in Xata user interfaces
     */
    ui?: {
        /**
         * The user-selected color for this database across interfaces
         */
        color?: string;
    };
};
declare type DEPRECATEDListDatabasesResponse = {
    /**
     * A list of databases in a Xata workspace
     */
    databases?: DEPRECATEDDatabaseMetadata[];
};
declare type ListBranchesResponse = {
    databaseName: string;
    branches: Branch[];
};
declare type ListGitBranchesResponse = {
    mapping: {
        gitBranch: string;
        xataBranch: string;
    }[];
};
declare type Branch = {
    name: string;
    createdAt: DateTime;
};
/**
 * @example {"repository":"github.com/my/repository","branch":"feature-login","stage":"testing","labels":["epic-100"]}
 * @x-go-type xata.BranchMetadata
 */
declare type BranchMetadata = {
    /**
     * @minLength 1
     */
    repository?: string;
    branch?: BranchName;
    /**
     * @minLength 1
     */
    stage?: string;
    labels?: string[];
};
declare type DBBranch = {
    databaseName: DBName;
    branchName: BranchName;
    createdAt: DateTime;
    id: string;
    version: number;
    lastMigrationID: string;
    metadata?: BranchMetadata;
    startedFrom?: StartedFromMetadata;
    schema: Schema;
};
declare type StartedFromMetadata = {
    branchName: BranchName;
    dbBranchID: string;
    migrationID: string;
};
/**
 * @x-go-type xata.Schema
 */
declare type Schema = {
    tables: Table[];
    tablesOrder?: string[];
};
declare type SchemaEditScript = {
    sourceMigrationID?: string;
    targetMigrationID?: string;
    operations: MigrationOp[];
};
declare type Table = {
    id?: string;
    name: TableName;
    columns: Column[];
    revLinks?: RevLink[];
};
declare type Column = {
    name: string;
    type: 'bool' | 'int' | 'float' | 'string' | 'text' | 'email' | 'multiple' | 'link' | 'object' | 'datetime';
    link?: ColumnLink;
    notNull?: boolean;
    defaultValue?: string;
    unique?: boolean;
    columns?: Column[];
};
declare type ColumnLink = {
    table: string;
};
declare type RevLink = {
    linkID: string;
    table: string;
};
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type BranchName = string;
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type DBName = string;
/**
 * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
 *
 * @pattern [a-zA-Z0-9_\-~]+:[a-zA-Z0-9_\-~]+
 */
declare type DBBranchName = string;
/**
 * @pattern [a-zA-Z0-9_\-~]+
 */
declare type TableName = string;
/**
 * @pattern [a-zA-Z0-9_\-~\.]+
 */
declare type ColumnName = string;
declare type MetricsDatapoint = {
    timestamp: string;
    value: number;
};
declare type MetricsLatency = {
    p50?: MetricsDatapoint[];
    p90?: MetricsDatapoint[];
};
declare type BranchMigration = {
    id?: string;
    parentID?: string;
    status: string;
    title?: string;
    lastGitRevision?: string;
    localChanges: boolean;
    createdAt?: DateTime;
    newTables?: {
        [key: string]: Table;
    };
    removedTables?: string[];
    tableMigrations?: {
        [key: string]: TableMigration;
    };
    newTableOrder: string[];
    renamedTables?: TableRename[];
};
declare type TableMigration = {
    newColumns?: {
        [key: string]: Column;
    };
    removedColumns?: string[];
    modifiedColumns?: ColumnMigration[];
    newColumnOrder: string[];
};
declare type ColumnMigration = {
    old: Column;
    ['new']: Column;
};
declare type Commit = {
    title?: string;
    message?: string;
    id: string;
    parentID?: string;
    mergeParentID?: string;
    status: MigrationStatus;
    createdAt: DateTime;
    modifiedAt?: DateTime;
    operations: MigrationOp[];
};
declare type MigrationStatus = 'completed' | 'pending' | 'failed';
/**
 * Branch schema migration.
 */
declare type Migration = {
    parentID?: string;
    operations: MigrationOp[];
};
/**
 * Branch schema migration operations.
 */
declare type MigrationOp = MigrationTableOp | MigrationColumnOp;
declare type MigrationTableOp = {
    addTable: TableOpAdd;
} | {
    removeTable: TableOpRemove;
} | {
    renameTable: TableOpRename;
};
declare type MigrationColumnOp = {
    addColumn: ColumnOpAdd;
} | {
    removeColumn: ColumnOpRemove;
} | {
    renameColumn: ColumnOpRename;
};
declare type TableOpAdd = {
    table: string;
};
declare type TableOpRemove = {
    table: string;
};
declare type TableOpRename = {
    oldName: string;
    newName: string;
};
declare type ColumnOpAdd = {
    table: string;
    column: Column;
};
declare type ColumnOpRemove = {
    table: string;
    column: string;
};
declare type ColumnOpRename = {
    table: string;
    oldName: string;
    newName: string;
};
/**
 * The migration request number.
 *
 * @minimum 0
 * @x-go-type migration.RequestNumber
 */
declare type MigrationRequestNumber = number;
declare type MigrationRequest = {
    number?: MigrationRequestNumber;
    /**
     * Migration request creation timestamp.
     */
    createdAt?: DateTime;
    /**
     * Last modified timestamp.
     */
    modifiedAt?: DateTime;
    /**
     * Timestamp when the migration request was closed.
     */
    closedAt?: DateTime;
    /**
     * Timestamp when the migration request was merged.
     */
    mergedAt?: DateTime;
    status?: 'open' | 'closed' | 'merging' | 'merged';
    /**
     * The migration request title.
     */
    title?: string;
    /**
     * The migration request body with detailed description.
     */
    body?: string;
    /**
     * Name of the source branch.
     */
    source?: string;
    /**
     * Name of the target branch.
     */
    target?: string;
};
declare type SortExpression = string[] | {
    [key: string]: SortOrder;
} | {
    [key: string]: SortOrder;
}[];
declare type SortOrder = 'asc' | 'desc';
/**
 * Maximum [Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance) for the search terms. The Levenshtein
 * distance is the number of one character changes needed to make two strings equal. The default is 1, meaning that single
 * character typos per word are tollerated by search. You can set it to 0 to remove the typo tollerance or set it to 2
 * to allow two typos in a word.
 *
 * @default 1
 * @maximum 2
 * @minimum 0
 */
declare type FuzzinessExpression = number;
/**
 * If the prefix type is set to "disabled" (the default), the search only matches full words. If the prefix type is set to "phrase", the search will return results that match prefixes of the search phrase.
 */
declare type PrefixExpression = 'phrase' | 'disabled';
/**
 * The target expression is used to filter the search results by the target columns.
 */
declare type TargetExpression = (string | {
    /**
     * The name of the column.
     */
    column: string;
    /**
     * The weight of the column.
     *
     * @default 1
     * @maximum 10
     * @minimum 1
     */
    weight?: number;
})[];
/**
 * @minProperties 1
 */
declare type FilterExpression = {
    $exists?: string;
    $existsNot?: string;
    $any?: FilterList;
    $all?: FilterList;
    $none?: FilterList;
    $not?: FilterList;
} & {
    [key: string]: FilterColumn;
};
/**
 * The description of the summaries you wish to receive. Set each key to be the field name
 * you'd like for the summary. These names must not collide with other columns you've
 * requested from `columns`; including implicit requests like `settings.*`.
 *
 * The value for each key needs to be an object. This object should contain one key and one
 * value only. In this object, the key should be set to the summary function you wish to use
 * and the value set to the column name to be summarized.
 *
 * The column being summarized cannot be an internal column (id, xata.*), nor the base of
 * an object, i.e. if `settings` is an object with `dark_mode` as a field, you may summarize
 * `settings.dark_mode` but not `settings` nor `settings.*`.
 *
 * @example {"all_users":{"count":"*"}}
 * @example {"total_created":{"count":"created_at"}}
 * @example {"min_cost":{"min":"cost"}}
 * @example {"max_happiness":{"max":"happiness"}}
 * @example {"total_revenue":{"sum":"revenue"}}
 * @example {"average_speed":{"average":"speed"}}
 * @x-go-type xbquery.SummaryList
 */
declare type SummaryExpressionList = {
    [key: string]: SummaryExpression;
};
/**
 * A summary expression is the description of a single summary operation. It consists of a single
 * key representing the operation, and a value representing the column to be operated on.
 *
 * The column being summarized cannot be an internal column (id, xata.*), nor the base of
 * an object, i.e. if `settings` is an object with `dark_mode` as a field, you may summarize
 * `settings.dark_mode` but not `settings` nor `settings.*`.
 *
 * We currently support several aggregation functions. Not all functions can be run on all column
 * types.
 *
 * - `count` is used to count the number of records in each group. Use `{"count": "*"}` to count
 *   all columns present, otherwise `{"count": "<column_path>"}` to count the number of non-null
 *   values are present at column path.
 *
 *   Count can be used on any column type, and always returns an int.
 *
 * - `min` calculates the minimum value in each group. `min` is compatible with most types;
 *   string, multiple, text, email, int, float, and datetime. It returns a value of the same
 *   type as operated on. This means that `{"lowest_latency": {"min": "latency"}}` where
 *   `latency` is an int, will always return an int.
 *
 * - `max` calculates the maximum value in each group. `max` shares the same compatibility as
 *   `min`.
 *
 * - `sum` adds up all values in a group. `sum` can be run on `int` and `float` types, and will
 *   return a value of the same type as requested.
 *
 * - `average` averages all values in a group. `average` can be run on `int` and `float` types, and
 *   always returns a float.
 *
 * @example {"count":"deleted_at"}
 * @x-go-type xbquery.Summary
 */
declare type SummaryExpression = Record<string, any>;
/**
 * The description of the aggregations you wish to receive.
 *
 * @example {"totalCount":{"count":"*"},"dailyActiveUsers":{"dateHistogram":{"column":"date","interval":"1d"},"aggs":{"uniqueUsers":{"uniqueCount":{"column":"userID"}}}}}
 */
declare type AggExpressionMap = {
    [key: string]: AggExpression;
};
/**
 * The description of a single aggregation operation. It is an object with only one key-value pair.
 * The key represents the aggreagtion type, while the value is an object with the configuration of
 * the aggreagtion.
 *
 * @x-go-type xata.AggExpression
 */
declare type AggExpression = {
    count?: CountAgg;
} | {
    sum?: SumAgg;
} | {
    max?: MaxAgg;
} | {
    min?: MinAgg;
} | {
    average?: AverageAgg;
} | {
    uniqueCount?: UniqueCountAgg;
} | {
    dateHistogram?: DateHistogramAgg;
} | {
    topValues?: TopValuesAgg;
} | {
    numericHistogram?: NumericHistogramAgg;
};
/**
 * Count the number of records with an optional filter.
 */
declare type CountAgg = {
    filter?: FilterExpression;
} | '*';
/**
 * The sum of the numeric values in a particular column.
 */
declare type SumAgg = {
    /**
     * The column on which to compute the sum. Must be a numeric type.
     */
    column: string;
};
/**
 * The max of the numeric values in a particular column.
 */
declare type MaxAgg = {
    /**
     * The column on which to compute the max. Must be a numeric type.
     */
    column: string;
};
/**
 * The min of the numeric values in a particular column.
 */
declare type MinAgg = {
    /**
     * The column on which to compute the min. Must be a numeric type.
     */
    column: string;
};
/**
 * The average of the numeric values in a particular column.
 */
declare type AverageAgg = {
    /**
     * The column on which to compute the average. Must be a numeric type.
     */
    column: string;
};
/**
 * Count the number of distinct values in a particular column.
 */
declare type UniqueCountAgg = {
    /**
     * The column from where to count the unique values.
     */
    column: string;
    /**
     * The threshold under which the unique count is exact. If the number of unique
     * values in the column is higher than this threshold, the results are approximative.
     * Maximum value is 40,000, default value is 3000.
     */
    precisionThreshold?: number;
};
/**
 * Split data into buckets by a datetime column. Accepts sub-aggregations for each bucket.
 */
declare type DateHistogramAgg = {
    /**
     * The column to use for bucketing. Must be of type datetime.
     */
    column: string;
    /**
     * The fixed interval to use when bucketing.
     * It is fromatted as number + units, for example: `5d`, `20m`, `10s`.
     *
     * @pattern ^(\d+)(d|h|m|s|ms)$
     */
    interval?: string;
    /**
     * The calendar-aware interval to use when bucketing. Possible values are: `minute`,
     * `hour`, `day`, `week`, `month`, `quarter`, `year`.
     */
    calendarInterval?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';
    /**
     * The timezone to use for bucketing. By default, UTC is assumed.
     * The accepted format is as an ISO 8601 UTC offset. For example: `+01:00` or
     * `-08:00`.
     *
     * @pattern ^[+-][01]\d:[0-5]\d$
     */
    timezone?: string;
    aggs?: AggExpressionMap;
};
/**
 * Split data into buckets by the unique values in a column. Accepts sub-aggregations for each bucket.
 * The top values as ordered by the number of records (`$count`) are returned.
 */
declare type TopValuesAgg = {
    /**
     * The column to use for bucketing. Accepted types are `string`, `email`, `int`, `float`, or `bool`.
     */
    column: string;
    aggs?: AggExpressionMap;
    /**
     * The maximum number of unique values to return.
     *
     * @default 10
     * @maximum 1000
     */
    size?: number;
};
/**
 * Split data into buckets by dynamic numeric ranges. Accepts sub-aggregations for each bucket.
 */
declare type NumericHistogramAgg = {
    /**
     * The column to use for bucketing. Must be of numeric type.
     */
    column: string;
    /**
     * The numeric interval to use for bucketing. The resulting buckets will be ranges
     * with this value as size.
     *
     * @minimum 0
     */
    interval: number;
    /**
     * By default the bucket keys start with 0 and then continue in `interval` steps. The bucket
     * boundaries can be shiftend by using the offset option. For example, if the `interval` is 100,
     * but you prefer the bucket boundaries to be `[50, 150), [150, 250), etc.`, you can set `offset`
     * to 50.
     *
     * @default 0
     */
    offset?: number;
    aggs?: AggExpressionMap;
};
declare type HighlightExpression = {
    /**
     * Set to `false` to disable highlighting. By default it is `true`.
     */
    enabled?: boolean;
    /**
     * Set to `false` to disable HTML encoding in highlight snippets. By default it is `true`.
     */
    encodeHTML?: boolean;
};
/**
 * Booster Expression
 *
 * @x-go-type xata.BoosterExpression
 */
declare type BoosterExpression = {
    valueBooster?: ValueBooster$1;
} | {
    numericBooster?: NumericBooster$1;
} | {
    dateBooster?: DateBooster$1;
};
/**
 * Boost records with a particular value for a column.
 */
declare type ValueBooster$1 = {
    /**
     * The column in which to look for the value.
     */
    column: string;
    /**
     * The exact value to boost.
     */
    value: string | number | boolean;
    /**
     * The factor with which to multiply the score of the record.
     */
    factor: number;
};
/**
 * Boost records based on the value of a numeric column.
 */
declare type NumericBooster$1 = {
    /**
     * The column in which to look for the value.
     */
    column: string;
    /**
     * The factor with which to multiply the value of the column before adding it to the item score.
     */
    factor: number;
};
/**
 * Boost records based on the value of a datetime column. It is configured via "origin", "scale", and "decay". The further away from the "origin",
 * the more the score is decayed. The decay function uses an exponential function. For example if origin is "now", and scale is 10 days and decay is 0.5, it
 * should be interpreted as: a record with a date 10 days before/after origin will score 2 times less than a record with the date at origin.
 */
declare type DateBooster$1 = {
    /**
     * The column in which to look for the value.
     */
    column: string;
    /**
     * The datetime (formatted as RFC3339) from where to apply the score decay function. The maximum boost will be applied for records with values at this time.
     * If it is not specified, the current date and time is used.
     */
    origin?: string;
    /**
     * The duration at which distance from origin the score is decayed with factor, using an exponential function. It is fromatted as number + units, for example: `5d`, `20m`, `10s`.
     *
     * @pattern ^(\d+)(d|h|m|s|ms)$
     */
    scale: string;
    /**
     * The decay factor to expect at "scale" distance from the "origin".
     */
    decay: number;
};
declare type FilterList = FilterExpression | FilterExpression[];
declare type FilterColumn = FilterColumnIncludes | FilterPredicate | FilterList;
/**
 * @maxProperties 1
 * @minProperties 1
 */
declare type FilterColumnIncludes = {
    $includes?: FilterPredicate;
    $includesAny?: FilterPredicate;
    $includesAll?: FilterPredicate;
    $includesNone?: FilterPredicate;
};
declare type FilterPredicate = FilterValue | FilterPredicate[] | FilterPredicateOp | FilterPredicateRangeOp;
/**
 * @maxProperties 1
 * @minProperties 1
 */
declare type FilterPredicateOp = {
    $any?: FilterPredicate[];
    $all?: FilterPredicate[];
    $none?: FilterPredicate | FilterPredicate[];
    $not?: FilterPredicate | FilterPredicate[];
    $is?: FilterValue | FilterValue[];
    $isNot?: FilterValue | FilterValue[];
    $lt?: FilterRangeValue;
    $le?: FilterRangeValue;
    $gt?: FilterRangeValue;
    $ge?: FilterRangeValue;
    $contains?: string;
    $startsWith?: string;
    $endsWith?: string;
    $pattern?: string;
};
/**
 * @maxProperties 2
 * @minProperties 2
 */
declare type FilterPredicateRangeOp = {
    $lt?: FilterRangeValue;
    $le?: FilterRangeValue;
    $gt?: FilterRangeValue;
    $ge?: FilterRangeValue;
};
declare type FilterRangeValue = number | string;
declare type FilterValue = number | string | boolean;
/**
 * Pagination settings.
 */
declare type PageConfig = {
    /**
     * Query the next page that follow the cursor.
     */
    after?: string;
    /**
     * Query the previous page before the cursor.
     */
    before?: string;
    /**
     * Query the first page from the cursor.
     */
    start?: string;
    /**
     * Query the last page from the cursor.
     */
    end?: string;
    /**
     * Set page size. If the size is missing it is read from the cursor. If no cursor is given Xata will choose the default page size.
     *
     * @default 20
     */
    size?: number;
    /**
     * Use offset to skip entries. To skip pages set offset to a multiple of size.
     *
     * @default 0
     */
    offset?: number;
};
/**
 * @example name
 * @example email
 * @example created_at
 */
declare type ColumnsProjection = string[];
/**
 * Xata Table Record Metadata
 */
declare type RecordMeta = {
    id: RecordID;
    xata: {
        /**
         * The record's version. Can be used for optimistic concurrency control.
         */
        version: number;
        /**
         * The record's table name. APIs that return records from multiple tables will set this field accordingly.
         */
        table?: string;
        /**
         * Highlights of the record. This is used by the search APIs to indicate which fields and parts of the fields have matched the search.
         */
        highlight?: {
            [key: string]: string[] | {
                [key: string]: any;
            };
        };
        /**
         * The record's relevancy score. This is returned by the search APIs.
         */
        score?: number;
        /**
         * Encoding/Decoding errors
         */
        warnings?: string[];
    };
};
/**
 * @pattern [a-zA-Z0-9_-~:]+
 */
declare type RecordID = string;
/**
 * @example {"newName":"newName","oldName":"oldName"}
 */
declare type TableRename = {
    /**
     * @minLength 1
     */
    newName: string;
    /**
     * @minLength 1
     */
    oldName: string;
};
/**
 * Records metadata
 */
declare type RecordsMetadata = {
    page: {
        /**
         * last record id
         */
        cursor: string;
        /**
         * true if more records can be fetch
         */
        more: boolean;
    };
};
declare type AggResponse$1 = (number | null) | {
    values: ({
        $key: string | number;
        $count: number;
    } & {
        [key: string]: AggResponse$1;
    })[];
};
/**
 * A transaction operation
 */
declare type TransactionOperation = {
    insert: TransactionInsert;
} | {
    update: TransactionUpdate;
} | {
    ['delete']: TransactionDelete;
};
/**
 * Insert operation
 *
 * @x-go-type TxOperation
 */
declare type TransactionInsert = {
    /**
     * The table name
     */
    table: string;
    /**
     * The record to insert. The `id` field is optional; when specified, it will be used as the ID for the record.
     */
    record: {
        [key: string]: any;
    };
    /**
     * The version of the record you expect to be overwriting. Only valid with an
     * explicit ID is also set in the `record` key.
     */
    ifVersion?: number;
    /**
     * createOnly is used to change how Xata acts when an explicit ID is set in the `record` key.
     *
     * If `createOnly` is set to `true`, Xata will only attempt to insert the record. If there's a conflict, Xata
     * will cancel the transaction.
     *
     * If `createOnly` is set to `false`, Xata will attempt to insert the record. If there's no
     * conflict, the record is inserted. If there is a conflict, Xata will replace the record.
     */
    createOnly?: boolean;
};
/**
 * Update operation
 *
 * @x-go-type TxOperation
 */
declare type TransactionUpdate = {
    /**
     * The table name
     */
    table: string;
    id: RecordID;
    /**
     * The fields of the record you'd like to update
     */
    fields: {
        [key: string]: any;
    };
    /**
     * The version of the record you expect to be updating
     */
    ifVersion?: number;
    /**
     * Xata will insert this record if it cannot be found.
     */
    upsert?: boolean;
};
/**
 * A delete operation. The transaction will continue if no record matches the ID.
 *
 * @x-go-type TxOperation
 */
declare type TransactionDelete = {
    /**
     * The table name
     */
    table: string;
    id: RecordID;
};
/**
 * A result from an insert operation.
 */
declare type TransactionResultInsert = {
    /**
     * The number of affected rows
     */
    rows: number;
    id: RecordID;
};
/**
 * A result from an update operation.
 */
declare type TransactionResultUpdate = {
    /**
     * The number of affected rows
     */
    rows: number;
    id: RecordID;
};
/**
 * A result from a delete operation.
 */
declare type TransactionResultDelete = {
    /**
     * The number of affected rows
     */
    rows: number;
};
/**
 * An error message from a failing transaction operation
 */
declare type TransactionError = {
    /**
     * The index of the failing operation
     */
    index?: number;
    /**
     * The error message
     */
    message: string;
};
/**
 * @format date-time
 * @x-go-type string
 */
declare type DateTime = string;
/**
 * Xata Table Record Metadata
 */
declare type XataRecord$1 = RecordMeta & {
    [key: string]: any;
};

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */

declare type SimpleError = {
    id?: string;
    message: string;
};
declare type BulkError = {
    errors: {
        message?: string;
        status?: number;
    }[];
};
declare type BulkInsertResponse = {
    recordIDs: string[];
} | {
    records: XataRecord$1[];
};
declare type BranchMigrationPlan = {
    version: number;
    migration: BranchMigration;
};
declare type RecordResponse = XataRecord$1;
declare type SchemaCompareResponse = {
    source: Schema;
    target: Schema;
    edits: SchemaEditScript;
};
declare type RecordUpdateResponse = XataRecord$1 | {
    id: string;
    xata: {
        version: number;
    };
};
declare type QueryResponse = {
    records: XataRecord$1[];
    meta: RecordsMetadata;
};
declare type SchemaUpdateResponse = {
    /**
     * @minLength 1
     */
    migrationID: string;
    parentMigrationID: string;
    status: MigrationStatus;
};
declare type SummarizeResponse = {
    summaries: Record<string, any>[];
};
/**
 * @example {"aggs":{"dailyUniqueUsers":{"values":[{"key":"2022-02-22T22:22:22Z","uniqueUsers":134},{"key":"2022-02-23T22:22:22Z","uniqueUsers":90}]}}}
 */
declare type AggResponse = {
    aggs?: {
        [key: string]: AggResponse$1;
    };
};
declare type SearchResponse = {
    records: XataRecord$1[];
    warning?: string;
};
/**
 * @x-go-type TxResponse
 */
declare type TransactionSucceeded = {
    /**
     * An ordered array of results from the submitted operations that were executed
     */
    results: (TransactionResultInsert | TransactionResultUpdate | TransactionResultDelete)[];
};
/**
 * @x-go-type TxResponse
 */
declare type TransactionFailed = {
    /**
     * An array of errors from the submitted operations.
     */
    errors: TransactionError[];
};
declare type BadRequestError = {
    id?: string;
    message: string;
};
/**
 * @example {"message":"invalid API key"}
 */
declare type AuthError = {
    id?: string;
    message: string;
};

declare type DataPlaneFetcherExtraProps = {
    apiUrl: string;
    workspacesApiUrl: string | WorkspaceApiUrlBuilder;
    fetchImpl: FetchImpl;
    apiKey: string;
    trace: TraceFunction;
    signal?: AbortSignal;
    clientID?: string;
    sessionID?: string;
};
declare type ErrorWrapper<TError> = TError | {
    status: 'unknown';
    payload: string;
};

/**
 * Generated by @openapi-codegen
 *
 * @version 1.0
 */

declare type DEPRECATEDgetDatabaseListPathParams = {
    workspace: string;
    region: string;
};
declare type DEPRECATEDgetDatabaseListError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type DEPRECATEDgetDatabaseListVariables = {
    pathParams: DEPRECATEDgetDatabaseListPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * List all databases available in your Workspace.
 */
declare const dEPRECATEDgetDatabaseList: (variables: DEPRECATEDgetDatabaseListVariables, signal?: AbortSignal) => Promise<DEPRECATEDListDatabasesResponse>;
declare type GetBranchListPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type GetBranchListError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchListVariables = {
    pathParams: GetBranchListPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * List all available Branches
 */
declare const getBranchList: (variables: GetBranchListVariables, signal?: AbortSignal) => Promise<ListBranchesResponse>;
declare type DEPRECATEDcreateDatabasePathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type DEPRECATEDcreateDatabaseError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type DEPRECATEDcreateDatabaseResponse = {
    /**
     * @minLength 1
     */
    databaseName: string;
    branchName?: string;
    status: MigrationStatus;
};
declare type DEPRECATEDcreateDatabaseRequestBody = {
    /**
     * @minLength 1
     */
    branchName?: string;
    ui?: {
        color?: string;
    };
    metadata?: BranchMetadata;
};
declare type DEPRECATEDcreateDatabaseVariables = {
    body?: DEPRECATEDcreateDatabaseRequestBody;
    pathParams: DEPRECATEDcreateDatabasePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Create Database with identifier name
 */
declare const dEPRECATEDcreateDatabase: (variables: DEPRECATEDcreateDatabaseVariables, signal?: AbortSignal) => Promise<DEPRECATEDcreateDatabaseResponse>;
declare type DEPRECATEDdeleteDatabasePathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type DEPRECATEDdeleteDatabaseError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DEPRECATEDdeleteDatabaseResponse = {
    status: MigrationStatus;
};
declare type DEPRECATEDdeleteDatabaseVariables = {
    pathParams: DEPRECATEDdeleteDatabasePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Delete a database and all of its branches and tables permanently.
 */
declare const dEPRECATEDdeleteDatabase: (variables: DEPRECATEDdeleteDatabaseVariables, signal?: AbortSignal) => Promise<DEPRECATEDdeleteDatabaseResponse>;
declare type DEPRECATEDgetDatabaseMetadataPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type DEPRECATEDgetDatabaseMetadataError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DEPRECATEDgetDatabaseMetadataVariables = {
    pathParams: DEPRECATEDgetDatabaseMetadataPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Retrieve metadata of the given database
 */
declare const dEPRECATEDgetDatabaseMetadata: (variables: DEPRECATEDgetDatabaseMetadataVariables, signal?: AbortSignal) => Promise<DEPRECATEDDatabaseMetadata>;
declare type DEPRECATEDupdateDatabaseMetadataPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type DEPRECATEDupdateDatabaseMetadataError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DEPRECATEDupdateDatabaseMetadataRequestBody = {
    ui?: {
        /**
         * @minLength 1
         */
        color?: string;
    };
};
declare type DEPRECATEDupdateDatabaseMetadataVariables = {
    body?: DEPRECATEDupdateDatabaseMetadataRequestBody;
    pathParams: DEPRECATEDupdateDatabaseMetadataPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Update the color of the selected database
 */
declare const dEPRECATEDupdateDatabaseMetadata: (variables: DEPRECATEDupdateDatabaseMetadataVariables, signal?: AbortSignal) => Promise<DEPRECATEDDatabaseMetadata>;
declare type GetBranchDetailsPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type GetBranchDetailsError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchDetailsVariables = {
    pathParams: GetBranchDetailsPathParams;
} & DataPlaneFetcherExtraProps;
declare const getBranchDetails: (variables: GetBranchDetailsVariables, signal?: AbortSignal) => Promise<DBBranch>;
declare type CreateBranchPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type CreateBranchQueryParams = {
    /**
     * Name of source branch to branch the new schema from
     */
    from?: string;
};
declare type CreateBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CreateBranchResponse = {
    /**
     * @minLength 1
     */
    databaseName: string;
    branchName: string;
    status: MigrationStatus;
};
declare type CreateBranchRequestBody = {
    /**
     * Select the branch to fork from. Defaults to 'main'
     */
    from?: string;
    metadata?: BranchMetadata;
};
declare type CreateBranchVariables = {
    body?: CreateBranchRequestBody;
    pathParams: CreateBranchPathParams;
    queryParams?: CreateBranchQueryParams;
} & DataPlaneFetcherExtraProps;
declare const createBranch: (variables: CreateBranchVariables, signal?: AbortSignal) => Promise<CreateBranchResponse>;
declare type DeleteBranchPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type DeleteBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteBranchResponse = {
    status: MigrationStatus;
};
declare type DeleteBranchVariables = {
    pathParams: DeleteBranchPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Delete the branch in the database and all its resources
 */
declare const deleteBranch: (variables: DeleteBranchVariables, signal?: AbortSignal) => Promise<DeleteBranchResponse>;
declare type UpdateBranchMetadataPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type UpdateBranchMetadataError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateBranchMetadataVariables = {
    body?: BranchMetadata;
    pathParams: UpdateBranchMetadataPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Update the branch metadata
 */
declare const updateBranchMetadata: (variables: UpdateBranchMetadataVariables, signal?: AbortSignal) => Promise<undefined>;
declare type GetBranchMetadataPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type GetBranchMetadataError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchMetadataVariables = {
    pathParams: GetBranchMetadataPathParams;
} & DataPlaneFetcherExtraProps;
declare const getBranchMetadata: (variables: GetBranchMetadataVariables, signal?: AbortSignal) => Promise<BranchMetadata>;
declare type GetBranchStatsPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type GetBranchStatsError = ErrorWrapper<{
    status: 400;
    payload: SimpleError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchStatsResponse = {
    timestamp: string;
    interval: string;
    resolution: string;
    numberOfRecords?: MetricsDatapoint[];
    writesOverTime?: MetricsDatapoint[];
    readsOverTime?: MetricsDatapoint[];
    readLatency?: MetricsLatency;
    writeLatency?: MetricsLatency;
    warning?: string;
};
declare type GetBranchStatsVariables = {
    pathParams: GetBranchStatsPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Get branch usage metrics.
 */
declare const getBranchStats: (variables: GetBranchStatsVariables, signal?: AbortSignal) => Promise<GetBranchStatsResponse>;
declare type GetGitBranchesMappingPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type GetGitBranchesMappingError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type GetGitBranchesMappingVariables = {
    pathParams: GetGitBranchesMappingPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Lists all the git branches in the mapping, and their associated Xata branches.
 *
 * Example response:
 *
 * ```json
 * {
 *   "mappings": [
 *       {
 *         "gitBranch": "main",
 *         "xataBranch": "main"
 *       },
 *       {
 *         "gitBranch": "gitBranch1",
 *         "xataBranch": "xataBranch1"
 *       }
 *       {
 *         "gitBranch": "xataBranch2",
 *         "xataBranch": "xataBranch2"
 *       }
 *   ]
 * }
 * ```
 */
declare const getGitBranchesMapping: (variables: GetGitBranchesMappingVariables, signal?: AbortSignal) => Promise<ListGitBranchesResponse>;
declare type AddGitBranchesEntryPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type AddGitBranchesEntryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type AddGitBranchesEntryResponse = {
    /**
     * Warning message
     */
    warning?: string;
};
declare type AddGitBranchesEntryRequestBody = {
    /**
     * The name of the Git branch.
     */
    gitBranch: string;
    /**
     * The name of the Xata branch.
     */
    xataBranch: BranchName;
};
declare type AddGitBranchesEntryVariables = {
    body: AddGitBranchesEntryRequestBody;
    pathParams: AddGitBranchesEntryPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Adds an entry to the mapping of git branches to Xata branches. The git branch and the Xata branch must be present in the body of the request. If the Xata branch doesn't exist, a 400 error is returned.
 *
 * If the git branch is already present in the mapping, the old entry is overwritten, and a warning message is included in the response. If the git branch is added and didn't exist before, the response code is 204. If the git branch existed and it was overwritten, the response code is 201.
 *
 * Example request:
 *
 * ```json
 * // POST https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches
 * {
 *   "gitBranch": "fix/bug123",
 *   "xataBranch": "fix_bug"
 * }
 * ```
 */
declare const addGitBranchesEntry: (variables: AddGitBranchesEntryVariables, signal?: AbortSignal) => Promise<AddGitBranchesEntryResponse>;
declare type RemoveGitBranchesEntryPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type RemoveGitBranchesEntryQueryParams = {
    /**
     * The Git Branch to remove from the mapping
     */
    gitBranch: string;
};
declare type RemoveGitBranchesEntryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type RemoveGitBranchesEntryVariables = {
    pathParams: RemoveGitBranchesEntryPathParams;
    queryParams: RemoveGitBranchesEntryQueryParams;
} & DataPlaneFetcherExtraProps;
/**
 * Removes an entry from the mapping of git branches to Xata branches. The name of the git branch must be passed as a query parameter. If the git branch is not found, the endpoint returns a 404 status code.
 *
 * Example request:
 *
 * ```json
 * // DELETE https://tutorial-ng7s8c.xata.sh/dbs/demo/gitBranches?gitBranch=fix%2Fbug123
 * ```
 */
declare const removeGitBranchesEntry: (variables: RemoveGitBranchesEntryVariables, signal?: AbortSignal) => Promise<undefined>;
declare type ResolveBranchPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type ResolveBranchQueryParams = {
    /**
     * The Git Branch
     */
    gitBranch?: string;
    /**
     * Default branch to fallback to
     */
    fallbackBranch?: string;
};
declare type ResolveBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type ResolveBranchResponse = {
    branch: string;
    reason: {
        code: 'FOUND_IN_MAPPING' | 'BRANCH_EXISTS' | 'FALLBACK_BRANCH' | 'DEFAULT_BRANCH';
        message: string;
    };
};
declare type ResolveBranchVariables = {
    pathParams: ResolveBranchPathParams;
    queryParams?: ResolveBranchQueryParams;
} & DataPlaneFetcherExtraProps;
/**
 * In order to resolve the database branch, the following algorithm is used:
 * * if the `gitBranch` was provided and is found in the [git branches mapping](/api-reference/dbs/db_name/gitBranches), the associated Xata branch is returned
 * * else, if a Xata branch with the exact same name as `gitBranch` exists, return it
 * * else, if `fallbackBranch` is provided and a branch with that name exists, return it
 * * else, return the default branch of the DB (`main` or the first branch)
 *
 * Example call:
 *
 * ```json
 * // GET https://tutorial-ng7s8c.xata.sh/dbs/demo/dbs/demo/resolveBranch?gitBranch=test&fallbackBranch=tsg
 * ```
 *
 * Example response:
 *
 * ```json
 * {
 *   "branch": "main",
 *   "reason": {
 *     "code": "DEFAULT_BRANCH",
 *     "message": "Default branch for this database (main)"
 *   }
 * }
 * ```
 */
declare const resolveBranch: (variables: ResolveBranchVariables, signal?: AbortSignal) => Promise<ResolveBranchResponse>;
declare type GetBranchMigrationHistoryPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type GetBranchMigrationHistoryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchMigrationHistoryResponse = {
    startedFrom?: StartedFromMetadata;
    migrations?: BranchMigration[];
};
declare type GetBranchMigrationHistoryRequestBody = {
    limit?: number;
    startFrom?: string;
};
declare type GetBranchMigrationHistoryVariables = {
    body?: GetBranchMigrationHistoryRequestBody;
    pathParams: GetBranchMigrationHistoryPathParams;
} & DataPlaneFetcherExtraProps;
declare const getBranchMigrationHistory: (variables: GetBranchMigrationHistoryVariables, signal?: AbortSignal) => Promise<GetBranchMigrationHistoryResponse>;
declare type GetBranchMigrationPlanPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type GetBranchMigrationPlanError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchMigrationPlanVariables = {
    body: Schema;
    pathParams: GetBranchMigrationPlanPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Compute a migration plan from a target schema the branch should be migrated too.
 */
declare const getBranchMigrationPlan: (variables: GetBranchMigrationPlanVariables, signal?: AbortSignal) => Promise<BranchMigrationPlan>;
declare type ExecuteBranchMigrationPlanPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type ExecuteBranchMigrationPlanError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type ExecuteBranchMigrationPlanRequestBody = {
    version: number;
    migration: BranchMigration;
};
declare type ExecuteBranchMigrationPlanVariables = {
    body: ExecuteBranchMigrationPlanRequestBody;
    pathParams: ExecuteBranchMigrationPlanPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Apply a migration plan to the branch
 */
declare const executeBranchMigrationPlan: (variables: ExecuteBranchMigrationPlanVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type BranchTransactionPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type BranchTransactionError = ErrorWrapper<{
    status: 400;
    payload: TransactionFailed;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type BranchTransactionRequestBody = {
    operations: TransactionOperation[];
};
declare type BranchTransactionVariables = {
    body: BranchTransactionRequestBody;
    pathParams: BranchTransactionPathParams;
} & DataPlaneFetcherExtraProps;
declare const branchTransaction: (variables: BranchTransactionVariables, signal?: AbortSignal) => Promise<TransactionSucceeded>;
declare type QueryMigrationRequestsPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type QueryMigrationRequestsError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type QueryMigrationRequestsResponse = {
    migrationRequests: MigrationRequest[];
    meta: RecordsMetadata;
};
declare type QueryMigrationRequestsRequestBody = {
    filter?: FilterExpression;
    sort?: SortExpression;
    page?: PageConfig;
    columns?: ColumnsProjection;
};
declare type QueryMigrationRequestsVariables = {
    body?: QueryMigrationRequestsRequestBody;
    pathParams: QueryMigrationRequestsPathParams;
} & DataPlaneFetcherExtraProps;
declare const queryMigrationRequests: (variables: QueryMigrationRequestsVariables, signal?: AbortSignal) => Promise<QueryMigrationRequestsResponse>;
declare type CreateMigrationRequestPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    workspace: string;
    region: string;
};
declare type CreateMigrationRequestError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CreateMigrationRequestResponse = {
    number: number;
};
declare type CreateMigrationRequestRequestBody = {
    /**
     * The source branch.
     */
    source: string;
    /**
     * The target branch.
     */
    target: string;
    /**
     * The title.
     */
    title: string;
    /**
     * Optional migration request description.
     */
    body?: string;
};
declare type CreateMigrationRequestVariables = {
    body: CreateMigrationRequestRequestBody;
    pathParams: CreateMigrationRequestPathParams;
} & DataPlaneFetcherExtraProps;
declare const createMigrationRequest: (variables: CreateMigrationRequestVariables, signal?: AbortSignal) => Promise<CreateMigrationRequestResponse>;
declare type GetMigrationRequestPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    /**
     * The migration request number.
     */
    mrNumber: MigrationRequestNumber;
    workspace: string;
    region: string;
};
declare type GetMigrationRequestError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetMigrationRequestVariables = {
    pathParams: GetMigrationRequestPathParams;
} & DataPlaneFetcherExtraProps;
declare const getMigrationRequest: (variables: GetMigrationRequestVariables, signal?: AbortSignal) => Promise<MigrationRequest>;
declare type UpdateMigrationRequestPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    /**
     * The migration request number.
     */
    mrNumber: MigrationRequestNumber;
    workspace: string;
    region: string;
};
declare type UpdateMigrationRequestError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateMigrationRequestRequestBody = {
    /**
     * New migration request title.
     */
    title?: string;
    /**
     * New migration request description.
     */
    body?: string;
    /**
     * Change the migration request status.
     */
    status?: 'open' | 'closed';
};
declare type UpdateMigrationRequestVariables = {
    body?: UpdateMigrationRequestRequestBody;
    pathParams: UpdateMigrationRequestPathParams;
} & DataPlaneFetcherExtraProps;
declare const updateMigrationRequest: (variables: UpdateMigrationRequestVariables, signal?: AbortSignal) => Promise<undefined>;
declare type ListMigrationRequestsCommitsPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    /**
     * The migration request number.
     */
    mrNumber: MigrationRequestNumber;
    workspace: string;
    region: string;
};
declare type ListMigrationRequestsCommitsError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type ListMigrationRequestsCommitsResponse = {
    meta: {
        /**
         * last record id
         */
        cursor: string;
        /**
         * true if more records can be fetch
         */
        more: boolean;
    };
    logs: Commit[];
};
declare type ListMigrationRequestsCommitsRequestBody = {
    page?: {
        /**
         * Query the next page that follow the cursor.
         */
        after?: string;
        /**
         * Query the previous page before the cursor.
         */
        before?: string;
        /**
         * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.
         *
         * @default 20
         */
        size?: number;
    };
};
declare type ListMigrationRequestsCommitsVariables = {
    body?: ListMigrationRequestsCommitsRequestBody;
    pathParams: ListMigrationRequestsCommitsPathParams;
} & DataPlaneFetcherExtraProps;
declare const listMigrationRequestsCommits: (variables: ListMigrationRequestsCommitsVariables, signal?: AbortSignal) => Promise<ListMigrationRequestsCommitsResponse>;
declare type CompareMigrationRequestPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    /**
     * The migration request number.
     */
    mrNumber: MigrationRequestNumber;
    workspace: string;
    region: string;
};
declare type CompareMigrationRequestError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CompareMigrationRequestVariables = {
    pathParams: CompareMigrationRequestPathParams;
} & DataPlaneFetcherExtraProps;
declare const compareMigrationRequest: (variables: CompareMigrationRequestVariables, signal?: AbortSignal) => Promise<SchemaCompareResponse>;
declare type GetMigrationRequestIsMergedPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    /**
     * The migration request number.
     */
    mrNumber: MigrationRequestNumber;
    workspace: string;
    region: string;
};
declare type GetMigrationRequestIsMergedError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetMigrationRequestIsMergedResponse = {
    merged?: boolean;
};
declare type GetMigrationRequestIsMergedVariables = {
    pathParams: GetMigrationRequestIsMergedPathParams;
} & DataPlaneFetcherExtraProps;
declare const getMigrationRequestIsMerged: (variables: GetMigrationRequestIsMergedVariables, signal?: AbortSignal) => Promise<GetMigrationRequestIsMergedResponse>;
declare type MergeMigrationRequestPathParams = {
    /**
     * The Database Name
     */
    dbName: DBName;
    /**
     * The migration request number.
     */
    mrNumber: MigrationRequestNumber;
    workspace: string;
    region: string;
};
declare type MergeMigrationRequestError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type MergeMigrationRequestVariables = {
    pathParams: MergeMigrationRequestPathParams;
} & DataPlaneFetcherExtraProps;
declare const mergeMigrationRequest: (variables: MergeMigrationRequestVariables, signal?: AbortSignal) => Promise<Commit>;
declare type GetBranchSchemaHistoryPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type GetBranchSchemaHistoryError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetBranchSchemaHistoryResponse = {
    meta: {
        /**
         * last record id
         */
        cursor: string;
        /**
         * true if more records can be fetch
         */
        more: boolean;
    };
    logs: Commit[];
};
declare type GetBranchSchemaHistoryRequestBody = {
    page?: {
        /**
         * Query the next page that follow the cursor.
         */
        after?: string;
        /**
         * Query the previous page before the cursor.
         */
        before?: string;
        /**
         * Set page size. If the size is missing it is read from the cursor. If no cursor is given xata will choose the default page size.
         *
         * @default 20
         */
        size?: number;
    };
};
declare type GetBranchSchemaHistoryVariables = {
    body?: GetBranchSchemaHistoryRequestBody;
    pathParams: GetBranchSchemaHistoryPathParams;
} & DataPlaneFetcherExtraProps;
declare const getBranchSchemaHistory: (variables: GetBranchSchemaHistoryVariables, signal?: AbortSignal) => Promise<GetBranchSchemaHistoryResponse>;
declare type CompareBranchWithUserSchemaPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type CompareBranchWithUserSchemaError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CompareBranchWithUserSchemaRequestBody = {
    schema: Schema;
};
declare type CompareBranchWithUserSchemaVariables = {
    body: CompareBranchWithUserSchemaRequestBody;
    pathParams: CompareBranchWithUserSchemaPathParams;
} & DataPlaneFetcherExtraProps;
declare const compareBranchWithUserSchema: (variables: CompareBranchWithUserSchemaVariables, signal?: AbortSignal) => Promise<SchemaCompareResponse>;
declare type CompareBranchSchemasPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Database Name
     */
    branchName: BranchName;
    workspace: string;
    region: string;
};
declare type CompareBranchSchemasError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type CompareBranchSchemasVariables = {
    body?: Record<string, any>;
    pathParams: CompareBranchSchemasPathParams;
} & DataPlaneFetcherExtraProps;
declare const compareBranchSchemas: (variables: CompareBranchSchemasVariables, signal?: AbortSignal) => Promise<SchemaCompareResponse>;
declare type UpdateBranchSchemaPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type UpdateBranchSchemaError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateBranchSchemaVariables = {
    body: Migration;
    pathParams: UpdateBranchSchemaPathParams;
} & DataPlaneFetcherExtraProps;
declare const updateBranchSchema: (variables: UpdateBranchSchemaVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type PreviewBranchSchemaEditPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type PreviewBranchSchemaEditError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type PreviewBranchSchemaEditResponse = {
    original: Schema;
    updated: Schema;
};
declare type PreviewBranchSchemaEditRequestBody = {
    edits?: SchemaEditScript;
};
declare type PreviewBranchSchemaEditVariables = {
    body?: PreviewBranchSchemaEditRequestBody;
    pathParams: PreviewBranchSchemaEditPathParams;
} & DataPlaneFetcherExtraProps;
declare const previewBranchSchemaEdit: (variables: PreviewBranchSchemaEditVariables, signal?: AbortSignal) => Promise<PreviewBranchSchemaEditResponse>;
declare type ApplyBranchSchemaEditPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type ApplyBranchSchemaEditError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type ApplyBranchSchemaEditRequestBody = {
    edits: SchemaEditScript;
};
declare type ApplyBranchSchemaEditVariables = {
    body: ApplyBranchSchemaEditRequestBody;
    pathParams: ApplyBranchSchemaEditPathParams;
} & DataPlaneFetcherExtraProps;
declare const applyBranchSchemaEdit: (variables: ApplyBranchSchemaEditVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type CreateTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type CreateTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type CreateTableResponse = {
    branchName: string;
    /**
     * @minLength 1
     */
    tableName: string;
    status: MigrationStatus;
};
declare type CreateTableVariables = {
    pathParams: CreateTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Creates a new table with the given name. Returns 422 if a table with the same name already exists.
 */
declare const createTable: (variables: CreateTableVariables, signal?: AbortSignal) => Promise<CreateTableResponse>;
declare type DeleteTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type DeleteTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
}>;
declare type DeleteTableResponse = {
    status: MigrationStatus;
};
declare type DeleteTableVariables = {
    pathParams: DeleteTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Deletes the table with the given name.
 */
declare const deleteTable: (variables: DeleteTableVariables, signal?: AbortSignal) => Promise<DeleteTableResponse>;
declare type UpdateTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type UpdateTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateTableRequestBody = {
    /**
     * @minLength 1
     */
    name: string;
};
declare type UpdateTableVariables = {
    body: UpdateTableRequestBody;
    pathParams: UpdateTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Update table. Currently there is only one update operation supported: renaming the table by providing a new name.
 *
 * In the example below, we rename a table from users to people:
 *
 * ```json
 * // PATCH /db/test:main/tables/users
 *
 * {
 *   "name": "people"
 * }
 * ```
 */
declare const updateTable: (variables: UpdateTableVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type GetTableSchemaPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type GetTableSchemaError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetTableSchemaResponse = {
    columns: Column[];
};
declare type GetTableSchemaVariables = {
    pathParams: GetTableSchemaPathParams;
} & DataPlaneFetcherExtraProps;
declare const getTableSchema: (variables: GetTableSchemaVariables, signal?: AbortSignal) => Promise<GetTableSchemaResponse>;
declare type SetTableSchemaPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type SetTableSchemaError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 409;
    payload: SimpleError;
}>;
declare type SetTableSchemaRequestBody = {
    columns: Column[];
};
declare type SetTableSchemaVariables = {
    body: SetTableSchemaRequestBody;
    pathParams: SetTableSchemaPathParams;
} & DataPlaneFetcherExtraProps;
declare const setTableSchema: (variables: SetTableSchemaVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type GetTableColumnsPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type GetTableColumnsError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetTableColumnsResponse = {
    columns: Column[];
};
declare type GetTableColumnsVariables = {
    pathParams: GetTableColumnsPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Retrieves the list of table columns and their definition. This endpoint returns the column list with object columns being reported with their
 * full dot-separated path (flattened).
 */
declare const getTableColumns: (variables: GetTableColumnsVariables, signal?: AbortSignal) => Promise<GetTableColumnsResponse>;
declare type AddTableColumnPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type AddTableColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type AddTableColumnVariables = {
    body: Column;
    pathParams: AddTableColumnPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Adds a new column to the table. The body of the request should contain the column definition. In the column definition, the 'name' field should
 * contain the full path separated by dots. If the parent objects do not exists, they will be automatically created. For example,
 * passing `"name": "address.city"` will auto-create the `address` object if it doesn't exist.
 */
declare const addTableColumn: (variables: AddTableColumnVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type GetColumnPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Column name
     */
    columnName: ColumnName;
    workspace: string;
    region: string;
};
declare type GetColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetColumnVariables = {
    pathParams: GetColumnPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Get the definition of a single column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
declare const getColumn: (variables: GetColumnVariables, signal?: AbortSignal) => Promise<Column>;
declare type UpdateColumnPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Column name
     */
    columnName: ColumnName;
    workspace: string;
    region: string;
};
declare type UpdateColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type UpdateColumnRequestBody = {
    /**
     * @minLength 1
     */
    name: string;
};
declare type UpdateColumnVariables = {
    body: UpdateColumnRequestBody;
    pathParams: UpdateColumnPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Update column with partial data. Can be used for renaming the column by providing a new "name" field. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
declare const updateColumn: (variables: UpdateColumnVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type DeleteColumnPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Column name
     */
    columnName: ColumnName;
    workspace: string;
    region: string;
};
declare type DeleteColumnError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteColumnVariables = {
    pathParams: DeleteColumnPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Deletes the specified column. To refer to sub-objects, the column name can contain dots. For example `address.country`.
 */
declare const deleteColumn: (variables: DeleteColumnVariables, signal?: AbortSignal) => Promise<SchemaUpdateResponse>;
declare type InsertRecordPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type InsertRecordQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
};
declare type InsertRecordError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type InsertRecordVariables = {
    body?: Record<string, any>;
    pathParams: InsertRecordPathParams;
    queryParams?: InsertRecordQueryParams;
} & DataPlaneFetcherExtraProps;
/**
 * Insert a new Record into the Table
 */
declare const insertRecord: (variables: InsertRecordVariables, signal?: AbortSignal) => Promise<RecordUpdateResponse>;
declare type GetRecordPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Record name
     */
    recordId: RecordID;
    workspace: string;
    region: string;
};
declare type GetRecordQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
};
declare type GetRecordError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type GetRecordVariables = {
    pathParams: GetRecordPathParams;
    queryParams?: GetRecordQueryParams;
} & DataPlaneFetcherExtraProps;
/**
 * Retrieve record by ID
 */
declare const getRecord: (variables: GetRecordVariables, signal?: AbortSignal) => Promise<XataRecord$1>;
declare type InsertRecordWithIDPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Record name
     */
    recordId: RecordID;
    workspace: string;
    region: string;
};
declare type InsertRecordWithIDQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
    createOnly?: boolean;
    ifVersion?: number;
};
declare type InsertRecordWithIDError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type InsertRecordWithIDVariables = {
    body?: Record<string, any>;
    pathParams: InsertRecordWithIDPathParams;
    queryParams?: InsertRecordWithIDQueryParams;
} & DataPlaneFetcherExtraProps;
/**
 * By default, IDs are auto-generated when data is insterted into Xata. Sending a request to this endpoint allows us to insert a record with a pre-existing ID, bypassing the default automatic ID generation.
 */
declare const insertRecordWithID: (variables: InsertRecordWithIDVariables, signal?: AbortSignal) => Promise<RecordUpdateResponse>;
declare type UpdateRecordWithIDPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Record name
     */
    recordId: RecordID;
    workspace: string;
    region: string;
};
declare type UpdateRecordWithIDQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
    ifVersion?: number;
};
declare type UpdateRecordWithIDError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type UpdateRecordWithIDVariables = {
    body?: Record<string, any>;
    pathParams: UpdateRecordWithIDPathParams;
    queryParams?: UpdateRecordWithIDQueryParams;
} & DataPlaneFetcherExtraProps;
declare const updateRecordWithID: (variables: UpdateRecordWithIDVariables, signal?: AbortSignal) => Promise<RecordUpdateResponse>;
declare type UpsertRecordWithIDPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Record name
     */
    recordId: RecordID;
    workspace: string;
    region: string;
};
declare type UpsertRecordWithIDQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
    ifVersion?: number;
};
declare type UpsertRecordWithIDError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type UpsertRecordWithIDVariables = {
    body?: Record<string, any>;
    pathParams: UpsertRecordWithIDPathParams;
    queryParams?: UpsertRecordWithIDQueryParams;
} & DataPlaneFetcherExtraProps;
declare const upsertRecordWithID: (variables: UpsertRecordWithIDVariables, signal?: AbortSignal) => Promise<RecordUpdateResponse>;
declare type DeleteRecordPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    /**
     * The Record name
     */
    recordId: RecordID;
    workspace: string;
    region: string;
};
declare type DeleteRecordQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
};
declare type DeleteRecordError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type DeleteRecordVariables = {
    pathParams: DeleteRecordPathParams;
    queryParams?: DeleteRecordQueryParams;
} & DataPlaneFetcherExtraProps;
declare const deleteRecord: (variables: DeleteRecordVariables, signal?: AbortSignal) => Promise<XataRecord$1>;
declare type BulkInsertTableRecordsPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type BulkInsertTableRecordsQueryParams = {
    /**
     * Column filters
     */
    columns?: ColumnsProjection;
};
declare type BulkInsertTableRecordsError = ErrorWrapper<{
    status: 400;
    payload: BulkError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
} | {
    status: 422;
    payload: SimpleError;
}>;
declare type BulkInsertTableRecordsRequestBody = {
    records: Record<string, any>[];
};
declare type BulkInsertTableRecordsVariables = {
    body: BulkInsertTableRecordsRequestBody;
    pathParams: BulkInsertTableRecordsPathParams;
    queryParams?: BulkInsertTableRecordsQueryParams;
} & DataPlaneFetcherExtraProps;
/**
 * Bulk insert records
 */
declare const bulkInsertTableRecords: (variables: BulkInsertTableRecordsVariables, signal?: AbortSignal) => Promise<BulkInsertResponse>;
declare type QueryTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type QueryTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type QueryTableRequestBody = {
    filter?: FilterExpression;
    sort?: SortExpression;
    page?: PageConfig;
    columns?: ColumnsProjection;
    /**
     * The consistency level for this request.
     *
     * @default strong
     */
    consistency?: 'strong' | 'eventual';
};
declare type QueryTableVariables = {
    body?: QueryTableRequestBody;
    pathParams: QueryTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * The Query Table API can be used to retrieve all records in a table.
 * The API support filtering, sorting, selecting a subset of columns, and pagination.
 *
 * The overall structure of the request looks like this:
 *
 * ```json
 * // POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [...],
 *   "filter": {
 *     "$all": [...],
 *     "$any": [...]
 *     ...
 *   },
 *   "sort": {
 *     "multiple": [...]
 *     ...
 *   },
 *   "page": {
 *     ...
 *   }
 * }
 * ```
 *
 * ### Column selection
 *
 * If the `columns` array is not specified, all columns are included. For link
 * fields, only the ID column of the linked records is included in the response.
 *
 * If the `columns` array is specified, only the selected and internal
 * columns `id` and `xata` are included. The `*` wildcard can be used to
 * select all columns.
 *
 * For objects and link fields, if the column name of the object is specified, we
 * include all of its sub-keys. If only some sub-keys are specified (via dotted
 * notation, e.g. `"settings.plan"` ), then only those sub-keys from the object
 * are included.
 *
 * By the way of example, assuming two tables like this:
 *
 * ```json {"truncate": true}
 * {
 *   "tables": [
 *     {
 *       "name": "teams",
 *       "columns": [
 *         {
 *           "name": "name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "owner",
 *           "type": "link",
 *           "link": {
 *             "table": "users"
 *           }
 *         },
 *         {
 *           "name": "foundedDate",
 *           "type": "datetime"
 *         },
 *       ]
 *     },
 *     {
 *       "name": "users",
 *       "columns": [
 *         {
 *           "name": "email",
 *           "type": "email"
 *         },
 *         {
 *           "name": "full_name",
 *           "type": "string"
 *         },
 *         {
 *           "name": "address",
 *           "type": "object",
 *           "columns": [
 *             {
 *               "name": "street",
 *               "type": "string"
 *             },
 *             {
 *               "name": "number",
 *               "type": "int"
 *             },
 *             {
 *               "name": "zipcode",
 *               "type": "int"
 *             }
 *           ]
 *         },
 *         {
 *           "name": "team",
 *           "type": "link",
 *           "link": {
 *             "table": "teams"
 *           }
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * A query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.*"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   }
 * }
 * ```
 *
 * while a query like this:
 *
 * ```json
 * POST /db/<dbname>:<branch>/tables/<table>/query
 * {
 *   "columns": [
 *     "name",
 *     "address.street"
 *   ]
 * }
 * ```
 *
 * returns objects like:
 *
 * ```json
 * {
 *   "id": "id1"
 *   "xata": {
 *     "version": 0
 *   }
 *   "name": "Kilian",
 *   "address": {
 *     "street": "New street"
 *   }
 * }
 * ```
 *
 * If you want to return all columns from the main table and selected columns from the linked table, you can do it like this:
 *
 * ```json
 * {
 *   "columns": ["*", "team.name"]
 * }
 * ```
 *
 * The `"*"` in the above means all columns, including columns of objects. This returns data like:
 *
 * ```json
 * {
 *   "id": "id1"
 *   "xata": {
 *     "version": 0
 *   }
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team"
 *   }
 * }
 * ```
 *
 * If you want all columns of the linked table, you can do:
 *
 * ```json
 * {
 *   "columns": ["*", "team.*"]
 * }
 * ```
 *
 * This returns, for example:
 *
 * ```json
 * {
 *   "id": "id1"
 *   "xata": {
 *     "version": 0
 *   }
 *   "name": "Kilian",
 *   "email": "kilian@gmail.com",
 *   "address": {
 *     "street": "New street",
 *     "number": 41,
 *     "zipcode": 10407
 *   },
 *   "team": {
 *     "id": "XX",
 *     "xata": {
 *       "version": 0
 *     },
 *     "name": "first team",
 *     "code": "A1",
 *     "foundedDate": "2020-03-04T10:43:54.32Z"
 *   }
 * }
 * ```
 *
 * ### Filtering
 *
 * There are two types of operators:
 *
 * - Operators that work on a single column: `$is`, `$contains`, `$pattern`,
 *   `$includes`, `$gt`, etc.
 * - Control operators that combine multiple conditions: `$any`, `$all`, `$not` ,
 *   `$none`, etc.
 *
 * All operators start with an `$` to differentiate them from column names
 * (which are not allowed to start with a dollar sign).
 *
 * #### Exact matching and control operators
 *
 * Filter by one column:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": "value"
 *   }
 * }
 * ```
 *
 * This is equivalent to using the `$is` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$is": "value"
 *     }
 *   }
 * }
 * ```
 *
 * For example:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": "r2"
 *   }
 * }
 * ```
 *
 * Or:
 *
 * ```json
 * {
 *   "filter": {
 *     "name": {
 *       "$is": "r2"
 *     }
 *   }
 * }
 * ```
 *
 * For objects, both dots and nested versions work:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * ```json
 * {
 *   "filter": {
 *     "settings": {
 *       "plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * If you want to OR together multiple values, you can use the `$any` operator with an array of values:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.plan": { "$any": ["free", "paid"] }
 *   }
 * }
 * ```
 *
 * If you specify multiple columns in the same filter, they are logically AND'ed together:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.dark": true,
 *     "settings.plan": "free"
 *   }
 * }
 * ```
 *
 * The above matches if both conditions are met.
 *
 * To be more explicit about it, you can use `$all` or `$any`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": {
 *       "settings.dark": true,
 *       "settings.plan": "free"
 *     }
 *   }
 * }
 * ```
 *
 * The `$all` and `$any` operators can also receive an array of objects, which allows for repeating column names:
 *
 * ```json
 * {
 *   "filter": {
 *     "$any": [
 *       {
 *         "name": "r1"
 *       },
 *       {
 *         "name": "r2"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * You can check for a value being not-null with `$exists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$exists": "settings"
 *   }
 * }
 * ```
 *
 * This can be combined with `$all` or `$any` :
 *
 * ```json
 * {
 *   "filter": {
 *     "$all": [
 *       {
 *         "$exists": "settings"
 *       },
 *       {
 *         "$exists": "name"
 *       }
 *     ]
 *   }
 * }
 * ```
 *
 * Or you can use the inverse operator `$notExists`:
 *
 * ```json
 * {
 *   "filter": {
 *     "$notExists": "settings"
 *   }
 * }
 * ```
 *
 * #### Partial match
 *
 * `$contains` is the simplest operator for partial matching. We should generally
 * discourage overusing `$contains` because it typically can't make use of
 * indices.
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$contains": "value"
 *     }
 *   }
 * }
 * ```
 *
 * Wildcards are supported via the `$pattern` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$pattern": "v*alu?"
 *     }
 *   }
 * }
 * ```
 *
 * The `$pattern` operator accepts two wildcard characters:
 * * `*` matches zero or more characters
 * * `?` matches exactly one character
 *
 * If you want to match a string that contains a wildcard character, you can escape them using a backslash (`\`). You can escape a backslash by usign another backslash.
 *
 * We could also have `$endsWith` and `$startsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$endsWith": ".gz"
 *     },
 *     "<column_name>": {
 *       "$startsWith": "tmp-"
 *     }
 *   }
 * }
 * ```
 *
 * #### Numeric or datetime ranges
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$ge": 0,
 *       "$lt": 100
 *     }
 *   }
 * }
 * ```
 * Date ranges support the same operators, with the date using the format defined in
 * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339):
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$gt": "2019-10-12T07:20:50.52Z",
 *       "$lt": "2021-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 * The supported operators are `$gt`, `$lt`, `$ge`, `$le`.
 *
 * #### Negations
 *
 * A general `$not` operator can inverse any operation.
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * Note: in the above the two condition are AND together, so this does (NOT ( ...
 * AND ...))
 *
 * Or more complex:
 *
 * ```json
 * {
 *   "filter": {
 *     "$not": {
 *       "$any": [
 *         {
 *           "<column_name1>": "value1"
 *         },
 *         {
 *           "$all": [
 *             {
 *               "<column_name2>": "value2"
 *             },
 *             {
 *               "<column_name3>": "value3"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   }
 * }
 * ```
 *
 * The `$not: { $any: {}}` can be shorted using the `$none` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "$none": {
 *       "<column_name1>": "value1",
 *       "<column_name2>": "value1"
 *     }
 *   }
 * }
 * ```
 *
 * In addition, you can use operators like `$isNot` or `$notExists` to simplify expressions:
 *
 * ```json
 * {
 *   "filter": {
 *     "<column_name>": {
 *       "$isNot": "2019-10-12T07:20:50.52Z"
 *     }
 *   }
 * }
 * ```
 *
 * #### Working with arrays
 *
 * To test that an array contains a value, use `$includes`.
 *
 * ```json
 * {
 *   "filter": {
 *     "<array_name>": {
 *       "$includes": "value"
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` operator accepts a custom predicate that will check if any
 * array values matches the predicate. For example a complex predicate can include
 * the `$all` , `$contains` and `$endsWith` operators:
 *
 * ```json
 * {
 *   "filter": {
 *     "<array name>": {
 *       "$includes": {
 *         "$all": [
 *           { "$contains": "label" },
 *           { "$not": { "$endsWith": "-debug" } }
 *         ]
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * The `$includes` all operator succeeds if any column in the array matches the
 * predicate. The `$includesAll` operator succeeds if all array items match the
 * predicate. The `$includesNone` operator succeeds if no array item matches the
 * predicate. The `$includes` operator is a synonym for the `$includesAny`
 * operator.
 *
 * Here is an example of using the `$includesAll` operator:
 *
 * ```json
 * {
 *   "filter": {
 *     "settings.labels": {
 *       "$includesAll": [{ "$contains": "label" }]
 *     }
 *   }
 * }
 * ```
 *
 * The above matches if all label values contain the string "labels".
 *
 * ### Sorting
 *
 * Sorting by one element:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "asc"
 *   }
 * }
 * ```
 *
 * or descendently:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": {
 *     "index": "desc"
 *   }
 * }
 * ```
 *
 * Sorting by multiple fields:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "sort": [
 *     {
 *       "index": "desc"
 *     },
 *     {
 *       "createdAt": "desc"
 *     }
 *   ]
 * }
 * ```
 *
 * ### Pagination
 *
 * We offer cursor pagination and offset pagination. For queries that are expected to return more than 1000 records,
 * cursor pagination is needed in order to retrieve all of their results. The offset pagination method is limited to 1000 records.
 *
 * Example of size + offset pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 100,
 *     "offset": 200
 *   }
 * }
 * ```
 *
 * The `page.size` parameter represents the maximum number of records returned by this query. It has a default value of 20 and a maximum value of 200.
 * The `page.offset` parameter represents the number of matching records to skip. It has a default value of 0 and a maximum value of 800.
 *
 * Example of cursor pagination:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "after":"fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD"
 *   }
 * }
 * ```
 *
 * In the above example, the value of the `page.after` parameter is the cursor returned by the previous query. A sample response is shown below:
 *
 * ```json
 * {
 *   "meta": {
 *     "page": {
 *       "cursor": "fMoxCsIwFIDh3WP8c4amDai5hO5SJCRNfaVSeC9b6d1FD",
 *       "more": true
 *     }
 *   },
 *   "records": [...]
 * }
 * ```
 *
 * The `page` object might contain the follow keys, in addition to `size` and `offset` that were introduced before:
 *
 * - `after`: Return the next page 'after' the current cursor
 * - `before`: Return the previous page 'before' the current cursor.
 * - `start`: Resets the given cursor position to the beginning of the query result set.
 * Will return the first N records from the query result, where N is the `page.size` parameter.
 * - `end`: Resets the give cursor position to the end for the query result set.
 * Returns the last N records from the query result, where N is the `page.size` parameter.
 *
 * The request will fail if an invalid cursor value is given to `page.before`,
 * `page.after`, `page.start` , or `page.end`. No other cursor setting can be
 * used if `page.start` or `page.end` is set in a query.
 *
 * If both `page.before` and `page.after` parameters are present we treat the
 * request as a range query. The range query will return all entries after
 * `page.after`, but before `page.before`, up to `page.size` or the maximum
 * page size. This query requires both cursors to use the same filters and sort
 * settings, plus we require `page.after < page.before`. The range query returns
 * a new cursor. If the range encompass multiple pages the next page in the range
 * can be queried by update `page.after` to the returned cursor while keeping the
 * `page.before` cursor from the first range query.
 *
 * The `filter` , `columns`, `sort` , and `page.size` configuration will be
 * encoded with the cursor. The pagination request will be invalid if
 * `filter` or `sort` is set. The columns returned and page size can be changed
 * anytime by passing the `columns` or `page.size` settings to the next query.
 *
 * **Special cursors:**
 *
 * - `page.after=end`: Result points past the last entry. The list of records
 *   returned is empty, but `page.meta.cursor` will include a cursor that can be
 *   used to "tail" the table from the end waiting for new data to be inserted.
 * - `page.before=end`: This cursor returns the last page.
 * - `page.start=<cursor>`: Start at the beginning of the result set of the <cursor> query. This is equivalent to querying the
 *   first page without a cursor but applying `filter` and `sort` . Yet the `page.start`
 *   cursor can be convenient at times as user code does not need to remember the
 *   filter, sort, columns or page size configuration. All these information are
 *   read from the cursor.
 * - `page.end=<cursor>`: Move to the end of the result set of the <cursor> query. This is equivalent to querying the
 *   last page with `page.before=end`, `filter`, and `sort` . Yet the
 *   `page.end` cursor can be more convenient at times as user code does not
 *   need to remember the filter, sort, columns or page size configuration. All
 *   these information are read from the cursor.
 *
 * When using special cursors like `page.after="end"` or `page.before="end"`, we
 * still allow `filter` and `sort` to be set.
 *
 * Example of getting the last page:
 *
 * ```json
 * POST /db/demo:main/tables/table/query
 * {
 *   "page": {
 *     "size": 10,
 *     "before": "end"
 *   }
 * }
 * ```
 */
declare const queryTable: (variables: QueryTableVariables, signal?: AbortSignal) => Promise<QueryResponse>;
declare type SearchBranchPathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    workspace: string;
    region: string;
};
declare type SearchBranchError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type SearchBranchRequestBody = {
    /**
     * An array with the tables in which to search. By default, all tables are included. Optionally, filters can be included that apply to each table.
     */
    tables?: (string | {
        /**
         * The name of the table.
         */
        table: string;
        filter?: FilterExpression;
        target?: TargetExpression;
        boosters?: BoosterExpression[];
    })[];
    /**
     * The query string.
     *
     * @minLength 1
     */
    query: string;
    fuzziness?: FuzzinessExpression;
    prefix?: PrefixExpression;
    highlight?: HighlightExpression;
};
declare type SearchBranchVariables = {
    body: SearchBranchRequestBody;
    pathParams: SearchBranchPathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Run a free text search operation across the database branch.
 */
declare const searchBranch: (variables: SearchBranchVariables, signal?: AbortSignal) => Promise<SearchResponse>;
declare type SearchTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type SearchTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type SearchTableRequestBody = {
    /**
     * The query string.
     *
     * @minLength 1
     */
    query: string;
    fuzziness?: FuzzinessExpression;
    target?: TargetExpression;
    prefix?: PrefixExpression;
    filter?: FilterExpression;
    highlight?: HighlightExpression;
    boosters?: BoosterExpression[];
};
declare type SearchTableVariables = {
    body: SearchTableRequestBody;
    pathParams: SearchTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * Run a free text search operation in a particular table.
 *
 * The endpoint accepts a `query` parameter that is used for the free text search and a set of structured filters (via the `filter` parameter) that are applied before the search. The `filter` parameter uses the same syntax as the [query endpoint](/api-reference/db/db_branch_name/tables/table_name/) with the following exceptions:
 * * filters `$contains`, `$startsWith`, `$endsWith` don't work on columns of type `text`
 * * filtering on columns of type `multiple` is currently unsupported
 */
declare const searchTable: (variables: SearchTableVariables, signal?: AbortSignal) => Promise<SearchResponse>;
declare type SummarizeTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type SummarizeTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type SummarizeTableRequestBody = {
    filter?: FilterExpression;
    columns?: ColumnsProjection;
    summaries?: SummaryExpressionList;
    sort?: SortExpression;
    summariesFilter?: FilterExpression;
    /**
     * The consistency level for this request.
     *
     * @default strong
     */
    consistency?: 'strong' | 'eventual';
    page?: {
        /**
         * The number of records returned by summarize. If the amount of data you have exceeds this, or you have
         * more complex reporting requirements, we recommend that you use the aggregate endpoint instead.
         *
         * @default 20
         * @maximum 1000
         * @minimum 1
         */
        size?: number;
    };
};
declare type SummarizeTableVariables = {
    body?: SummarizeTableRequestBody;
    pathParams: SummarizeTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * This endpoint allows you to (optionally) define groups, and then to run
 * calculations on the values in each group. This is most helpful when
 * you'd like to understand the data you have in your database.
 *
 * A group is a combination of unique values. If you create a group for
 * `sold_by`, `product_name`, we will return one row for every combination
 * of `sold_by` and `product_name` you have in your database. When you
 * want to calculate statistics, you define these groups and ask Xata to
 * calculate data on each group.
 *
 * **Some questions you can ask of your data:**
 *
 * How many records do I have in this table?
 * - Set `columns: []` as we we want data from the entire table, so we ask
 * for no groups.
 * - Set `summaries: {"total": {"count": "*"}}` in order to see the count
 * of all records. We use `count: *` here we'd like to know the total
 * amount of rows; ignoring whether they are `null` or not.
 *
 * What are the top total sales for each product in July 2022 and sold
 * more than 10 units?
 * - Set `filter: {soldAt: {
 *   "$ge": "2022-07-01T00:00:00.000Z",
 *   "$lt": "2022-08-01T00:00:00.000Z"}
 * }`
 * in order to limit the result set to sales recorded in July 2022.
 * - Set `columns: [product_name]` as we'd like to run calculations on
 * each unique product name in our table. Setting `columns` like this will
 * produce one row per unique product name.
 * - Set `summaries: {"total_sales": {"count": "product_name"}}` as we'd
 * like to create a field called "total_sales" for each group. This field
 * will count all rows in each group with non-null product names.
 * - Set `sort: [{"total_sales": "desc"}]` in order to bring the rows with
 * the highest total_sales field to the top.
 * - Set `summariesFilter: {"total_sales": {"$ge": 10}}` to only send back data
 * with greater than or equal to 10 units.
 *
 * `columns`: tells Xata how to create each group. If you add `product_id`
 * we will create a new group for every unique `product_id`.
 *
 * `summaries`: tells Xata which calculations to run on each group. Xata
 * currently supports count, min, max, sum, average.
 *
 * `sort`: tells Xata in which order you'd like to see results. You may
 * sort by fields specified in `columns` as well as the summary names
 * defined in `summaries`.
 *
 * note: Sorting on summarized values can be slower on very large tables;
 * this will impact your rate limit significantly more than other queries.
 * Try use `filter` to reduce the amount of data being processed in order
 * to reduce impact on your limits.
 *
 * `summariesFilter`: tells Xata how to filter the results of a summary.
 * It has the same syntax as `filter`, however, by using `summariesFilter`
 * you may also filter on the results of a query.
 *
 * note: This is a much slower to use than `filter`. We recommend using
 * `filter` wherever possible and `summariesFilter` when it's not
 * possible to use `filter`.
 *
 * `page.size`: tells Xata how many records to return. If unspecified, Xata
 * will return the default size.
 */
declare const summarizeTable: (variables: SummarizeTableVariables, signal?: AbortSignal) => Promise<SummarizeResponse>;
declare type AggregateTablePathParams = {
    /**
     * The DBBranchName matches the pattern `{db_name}:{branch_name}`.
     */
    dbBranchName: DBBranchName;
    /**
     * The Table name
     */
    tableName: TableName;
    workspace: string;
    region: string;
};
declare type AggregateTableError = ErrorWrapper<{
    status: 400;
    payload: BadRequestError;
} | {
    status: 401;
    payload: AuthError;
} | {
    status: 404;
    payload: SimpleError;
}>;
declare type AggregateTableRequestBody = {
    filter?: FilterExpression;
    aggs?: AggExpressionMap;
};
declare type AggregateTableVariables = {
    body?: AggregateTableRequestBody;
    pathParams: AggregateTablePathParams;
} & DataPlaneFetcherExtraProps;
/**
 * This endpoint allows you to run aggragations (analytics) on the data from one table.
 * While the summary endpoint is served from a transactional store and the results are strongly
 * consistent, the aggregate endpoint is served from our columnar store and the results are
 * only eventually consistent. On the other hand, the aggregate endpoint uses a
 * store that is more appropiate for analytics, makes use of approximative algorithms
 * (e.g for cardinality), and is generally faster and can do more complex aggregations.
 */
declare const aggregateTable: (variables: AggregateTableVariables, signal?: AbortSignal) => Promise<AggResponse>;

declare const operationsByTag: {
    branch: {
        getBranchList: (variables: GetBranchListVariables, signal?: AbortSignal | undefined) => Promise<ListBranchesResponse>;
        getBranchDetails: (variables: GetBranchDetailsVariables, signal?: AbortSignal | undefined) => Promise<DBBranch>;
        createBranch: (variables: CreateBranchVariables, signal?: AbortSignal | undefined) => Promise<CreateBranchResponse>;
        deleteBranch: (variables: DeleteBranchVariables, signal?: AbortSignal | undefined) => Promise<DeleteBranchResponse>;
        updateBranchMetadata: (variables: UpdateBranchMetadataVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        getBranchMetadata: (variables: GetBranchMetadataVariables, signal?: AbortSignal | undefined) => Promise<BranchMetadata>;
        getBranchStats: (variables: GetBranchStatsVariables, signal?: AbortSignal | undefined) => Promise<GetBranchStatsResponse>;
        getGitBranchesMapping: (variables: GetGitBranchesMappingVariables, signal?: AbortSignal | undefined) => Promise<ListGitBranchesResponse>;
        addGitBranchesEntry: (variables: AddGitBranchesEntryVariables, signal?: AbortSignal | undefined) => Promise<AddGitBranchesEntryResponse>;
        removeGitBranchesEntry: (variables: RemoveGitBranchesEntryVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        resolveBranch: (variables: ResolveBranchVariables, signal?: AbortSignal | undefined) => Promise<ResolveBranchResponse>;
    };
    records: {
        branchTransaction: (variables: BranchTransactionVariables, signal?: AbortSignal | undefined) => Promise<TransactionSucceeded>;
        insertRecord: (variables: InsertRecordVariables, signal?: AbortSignal | undefined) => Promise<RecordUpdateResponse>;
        getRecord: (variables: GetRecordVariables, signal?: AbortSignal | undefined) => Promise<XataRecord$1>;
        insertRecordWithID: (variables: InsertRecordWithIDVariables, signal?: AbortSignal | undefined) => Promise<RecordUpdateResponse>;
        updateRecordWithID: (variables: UpdateRecordWithIDVariables, signal?: AbortSignal | undefined) => Promise<RecordUpdateResponse>;
        upsertRecordWithID: (variables: UpsertRecordWithIDVariables, signal?: AbortSignal | undefined) => Promise<RecordUpdateResponse>;
        deleteRecord: (variables: DeleteRecordVariables, signal?: AbortSignal | undefined) => Promise<XataRecord$1>;
        bulkInsertTableRecords: (variables: BulkInsertTableRecordsVariables, signal?: AbortSignal | undefined) => Promise<BulkInsertResponse>;
    };
    database: {
        dEPRECATEDgetDatabaseList: (variables: DEPRECATEDgetDatabaseListVariables, signal?: AbortSignal | undefined) => Promise<DEPRECATEDListDatabasesResponse>;
        dEPRECATEDcreateDatabase: (variables: DEPRECATEDcreateDatabaseVariables, signal?: AbortSignal | undefined) => Promise<DEPRECATEDcreateDatabaseResponse>;
        dEPRECATEDdeleteDatabase: (variables: DEPRECATEDdeleteDatabaseVariables, signal?: AbortSignal | undefined) => Promise<DEPRECATEDdeleteDatabaseResponse>;
        dEPRECATEDgetDatabaseMetadata: (variables: DEPRECATEDgetDatabaseMetadataVariables, signal?: AbortSignal | undefined) => Promise<DEPRECATEDDatabaseMetadata>;
        dEPRECATEDupdateDatabaseMetadata: (variables: DEPRECATEDupdateDatabaseMetadataVariables, signal?: AbortSignal | undefined) => Promise<DEPRECATEDDatabaseMetadata>;
    };
    migrations: {
        getBranchMigrationHistory: (variables: GetBranchMigrationHistoryVariables, signal?: AbortSignal | undefined) => Promise<GetBranchMigrationHistoryResponse>;
        getBranchMigrationPlan: (variables: GetBranchMigrationPlanVariables, signal?: AbortSignal | undefined) => Promise<BranchMigrationPlan>;
        executeBranchMigrationPlan: (variables: ExecuteBranchMigrationPlanVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
        getBranchSchemaHistory: (variables: GetBranchSchemaHistoryVariables, signal?: AbortSignal | undefined) => Promise<GetBranchSchemaHistoryResponse>;
        compareBranchWithUserSchema: (variables: CompareBranchWithUserSchemaVariables, signal?: AbortSignal | undefined) => Promise<SchemaCompareResponse>;
        compareBranchSchemas: (variables: CompareBranchSchemasVariables, signal?: AbortSignal | undefined) => Promise<SchemaCompareResponse>;
        updateBranchSchema: (variables: UpdateBranchSchemaVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
        previewBranchSchemaEdit: (variables: PreviewBranchSchemaEditVariables, signal?: AbortSignal | undefined) => Promise<PreviewBranchSchemaEditResponse>;
        applyBranchSchemaEdit: (variables: ApplyBranchSchemaEditVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
    };
    migrationRequests: {
        queryMigrationRequests: (variables: QueryMigrationRequestsVariables, signal?: AbortSignal | undefined) => Promise<QueryMigrationRequestsResponse>;
        createMigrationRequest: (variables: CreateMigrationRequestVariables, signal?: AbortSignal | undefined) => Promise<CreateMigrationRequestResponse>;
        getMigrationRequest: (variables: GetMigrationRequestVariables, signal?: AbortSignal | undefined) => Promise<MigrationRequest>;
        updateMigrationRequest: (variables: UpdateMigrationRequestVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        listMigrationRequestsCommits: (variables: ListMigrationRequestsCommitsVariables, signal?: AbortSignal | undefined) => Promise<ListMigrationRequestsCommitsResponse>;
        compareMigrationRequest: (variables: CompareMigrationRequestVariables, signal?: AbortSignal | undefined) => Promise<SchemaCompareResponse>;
        getMigrationRequestIsMerged: (variables: GetMigrationRequestIsMergedVariables, signal?: AbortSignal | undefined) => Promise<GetMigrationRequestIsMergedResponse>;
        mergeMigrationRequest: (variables: MergeMigrationRequestVariables, signal?: AbortSignal | undefined) => Promise<Commit>;
    };
    table: {
        createTable: (variables: CreateTableVariables, signal?: AbortSignal | undefined) => Promise<CreateTableResponse>;
        deleteTable: (variables: DeleteTableVariables, signal?: AbortSignal | undefined) => Promise<DeleteTableResponse>;
        updateTable: (variables: UpdateTableVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
        getTableSchema: (variables: GetTableSchemaVariables, signal?: AbortSignal | undefined) => Promise<GetTableSchemaResponse>;
        setTableSchema: (variables: SetTableSchemaVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
        getTableColumns: (variables: GetTableColumnsVariables, signal?: AbortSignal | undefined) => Promise<GetTableColumnsResponse>;
        addTableColumn: (variables: AddTableColumnVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
        getColumn: (variables: GetColumnVariables, signal?: AbortSignal | undefined) => Promise<Column>;
        updateColumn: (variables: UpdateColumnVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
        deleteColumn: (variables: DeleteColumnVariables, signal?: AbortSignal | undefined) => Promise<SchemaUpdateResponse>;
    };
    searchAndFilter: {
        queryTable: (variables: QueryTableVariables, signal?: AbortSignal | undefined) => Promise<QueryResponse>;
        searchBranch: (variables: SearchBranchVariables, signal?: AbortSignal | undefined) => Promise<SearchResponse>;
        searchTable: (variables: SearchTableVariables, signal?: AbortSignal | undefined) => Promise<SearchResponse>;
        summarizeTable: (variables: SummarizeTableVariables, signal?: AbortSignal | undefined) => Promise<SummarizeResponse>;
        aggregateTable: (variables: AggregateTableVariables, signal?: AbortSignal | undefined) => Promise<AggResponse>;
    };
    users: {
        getUser: (variables: ControlPlaneFetcherExtraProps, signal?: AbortSignal | undefined) => Promise<UserWithID>;
        updateUser: (variables: UpdateUserVariables, signal?: AbortSignal | undefined) => Promise<UserWithID>;
        deleteUser: (variables: ControlPlaneFetcherExtraProps, signal?: AbortSignal | undefined) => Promise<undefined>;
    };
    authentication: {
        getUserAPIKeys: (variables: ControlPlaneFetcherExtraProps, signal?: AbortSignal | undefined) => Promise<GetUserAPIKeysResponse>;
        createUserAPIKey: (variables: CreateUserAPIKeyVariables, signal?: AbortSignal | undefined) => Promise<CreateUserAPIKeyResponse>;
        deleteUserAPIKey: (variables: DeleteUserAPIKeyVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
    };
    workspaces: {
        getWorkspacesList: (variables: ControlPlaneFetcherExtraProps, signal?: AbortSignal | undefined) => Promise<GetWorkspacesListResponse>;
        createWorkspace: (variables: CreateWorkspaceVariables, signal?: AbortSignal | undefined) => Promise<Workspace>;
        getWorkspace: (variables: GetWorkspaceVariables, signal?: AbortSignal | undefined) => Promise<Workspace>;
        updateWorkspace: (variables: UpdateWorkspaceVariables, signal?: AbortSignal | undefined) => Promise<Workspace>;
        deleteWorkspace: (variables: DeleteWorkspaceVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        getWorkspaceMembersList: (variables: GetWorkspaceMembersListVariables, signal?: AbortSignal | undefined) => Promise<WorkspaceMembers>;
        updateWorkspaceMemberRole: (variables: UpdateWorkspaceMemberRoleVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        removeWorkspaceMember: (variables: RemoveWorkspaceMemberVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
    };
    invites: {
        inviteWorkspaceMember: (variables: InviteWorkspaceMemberVariables, signal?: AbortSignal | undefined) => Promise<WorkspaceInvite>;
        updateWorkspaceMemberInvite: (variables: UpdateWorkspaceMemberInviteVariables, signal?: AbortSignal | undefined) => Promise<WorkspaceInvite>;
        cancelWorkspaceMemberInvite: (variables: CancelWorkspaceMemberInviteVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        acceptWorkspaceMemberInvite: (variables: AcceptWorkspaceMemberInviteVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
        resendWorkspaceMemberInvite: (variables: ResendWorkspaceMemberInviteVariables, signal?: AbortSignal | undefined) => Promise<undefined>;
    };
    databases: {
        getDatabaseList: (variables: GetDatabaseListVariables, signal?: AbortSignal | undefined) => Promise<ListDatabasesResponse>;
        createDatabase: (variables: CreateDatabaseVariables, signal?: AbortSignal | undefined) => Promise<CreateDatabaseResponse>;
        deleteDatabase: (variables: DeleteDatabaseVariables, signal?: AbortSignal | undefined) => Promise<DeleteDatabaseResponse>;
        getDatabaseMetadata: (variables: GetDatabaseMetadataVariables, signal?: AbortSignal | undefined) => Promise<DatabaseMetadata>;
        updateDatabaseMetadata: (variables: UpdateDatabaseMetadataVariables, signal?: AbortSignal | undefined) => Promise<DatabaseMetadata>;
        listRegions: (variables: ListRegionsVariables, signal?: AbortSignal | undefined) => Promise<ListRegionsResponse>;
    };
};

declare type HostAliases = 'production' | 'staging';
declare type ProviderBuilder = {
    main: string;
    workspaces: string;
};
declare type HostProvider = HostAliases | ProviderBuilder;
declare function getHostUrl(provider: HostProvider, type: keyof ProviderBuilder): string;
declare function isHostProviderAlias(alias: HostProvider | string): alias is HostAliases;
declare function isHostProviderBuilder(builder: HostProvider): builder is ProviderBuilder;
declare function parseProviderString(provider?: string): HostProvider | null;
declare function parseWorkspacesUrlParts(url: string): {
    workspace: string;
    region: string;
} | null;

type responses_AuthError = AuthError;
type responses_BadRequestError = BadRequestError;
type responses_SimpleError = SimpleError;
type responses_BulkError = BulkError;
type responses_BulkInsertResponse = BulkInsertResponse;
type responses_BranchMigrationPlan = BranchMigrationPlan;
type responses_RecordResponse = RecordResponse;
type responses_SchemaCompareResponse = SchemaCompareResponse;
type responses_RecordUpdateResponse = RecordUpdateResponse;
type responses_QueryResponse = QueryResponse;
type responses_SchemaUpdateResponse = SchemaUpdateResponse;
type responses_SummarizeResponse = SummarizeResponse;
type responses_AggResponse = AggResponse;
type responses_SearchResponse = SearchResponse;
type responses_TransactionSucceeded = TransactionSucceeded;
type responses_TransactionFailed = TransactionFailed;
declare namespace responses {
  export {
    responses_AuthError as AuthError,
    responses_BadRequestError as BadRequestError,
    responses_SimpleError as SimpleError,
    responses_BulkError as BulkError,
    responses_BulkInsertResponse as BulkInsertResponse,
    responses_BranchMigrationPlan as BranchMigrationPlan,
    responses_RecordResponse as RecordResponse,
    responses_SchemaCompareResponse as SchemaCompareResponse,
    responses_RecordUpdateResponse as RecordUpdateResponse,
    responses_QueryResponse as QueryResponse,
    responses_SchemaUpdateResponse as SchemaUpdateResponse,
    responses_SummarizeResponse as SummarizeResponse,
    responses_AggResponse as AggResponse,
    responses_SearchResponse as SearchResponse,
    responses_TransactionSucceeded as TransactionSucceeded,
    responses_TransactionFailed as TransactionFailed,
  };
}

type schemas_BranchMetadata = BranchMetadata;
type schemas_BranchName = BranchName;
type schemas_DBName = DBName;
type schemas_DateTime = DateTime;
type schemas_MigrationStatus = MigrationStatus;
type schemas_DEPRECATEDDatabaseMetadata = DEPRECATEDDatabaseMetadata;
type schemas_DEPRECATEDListDatabasesResponse = DEPRECATEDListDatabasesResponse;
type schemas_ListBranchesResponse = ListBranchesResponse;
type schemas_ListGitBranchesResponse = ListGitBranchesResponse;
type schemas_Branch = Branch;
type schemas_DBBranch = DBBranch;
type schemas_StartedFromMetadata = StartedFromMetadata;
type schemas_Schema = Schema;
type schemas_SchemaEditScript = SchemaEditScript;
type schemas_Table = Table;
type schemas_Column = Column;
type schemas_ColumnLink = ColumnLink;
type schemas_RevLink = RevLink;
type schemas_DBBranchName = DBBranchName;
type schemas_TableName = TableName;
type schemas_ColumnName = ColumnName;
type schemas_MetricsDatapoint = MetricsDatapoint;
type schemas_MetricsLatency = MetricsLatency;
type schemas_BranchMigration = BranchMigration;
type schemas_TableMigration = TableMigration;
type schemas_ColumnMigration = ColumnMigration;
type schemas_Commit = Commit;
type schemas_Migration = Migration;
type schemas_MigrationOp = MigrationOp;
type schemas_MigrationTableOp = MigrationTableOp;
type schemas_MigrationColumnOp = MigrationColumnOp;
type schemas_TableOpAdd = TableOpAdd;
type schemas_TableOpRemove = TableOpRemove;
type schemas_TableOpRename = TableOpRename;
type schemas_ColumnOpAdd = ColumnOpAdd;
type schemas_ColumnOpRemove = ColumnOpRemove;
type schemas_ColumnOpRename = ColumnOpRename;
type schemas_MigrationRequestNumber = MigrationRequestNumber;
type schemas_MigrationRequest = MigrationRequest;
type schemas_SortExpression = SortExpression;
type schemas_SortOrder = SortOrder;
type schemas_FuzzinessExpression = FuzzinessExpression;
type schemas_PrefixExpression = PrefixExpression;
type schemas_TargetExpression = TargetExpression;
type schemas_FilterExpression = FilterExpression;
type schemas_SummaryExpressionList = SummaryExpressionList;
type schemas_SummaryExpression = SummaryExpression;
type schemas_AggExpressionMap = AggExpressionMap;
type schemas_AggExpression = AggExpression;
type schemas_CountAgg = CountAgg;
type schemas_SumAgg = SumAgg;
type schemas_MaxAgg = MaxAgg;
type schemas_MinAgg = MinAgg;
type schemas_AverageAgg = AverageAgg;
type schemas_UniqueCountAgg = UniqueCountAgg;
type schemas_DateHistogramAgg = DateHistogramAgg;
type schemas_TopValuesAgg = TopValuesAgg;
type schemas_NumericHistogramAgg = NumericHistogramAgg;
type schemas_HighlightExpression = HighlightExpression;
type schemas_BoosterExpression = BoosterExpression;
type schemas_FilterList = FilterList;
type schemas_FilterColumn = FilterColumn;
type schemas_FilterColumnIncludes = FilterColumnIncludes;
type schemas_FilterPredicate = FilterPredicate;
type schemas_FilterPredicateOp = FilterPredicateOp;
type schemas_FilterPredicateRangeOp = FilterPredicateRangeOp;
type schemas_FilterRangeValue = FilterRangeValue;
type schemas_FilterValue = FilterValue;
type schemas_PageConfig = PageConfig;
type schemas_ColumnsProjection = ColumnsProjection;
type schemas_RecordMeta = RecordMeta;
type schemas_RecordID = RecordID;
type schemas_TableRename = TableRename;
type schemas_RecordsMetadata = RecordsMetadata;
type schemas_TransactionOperation = TransactionOperation;
type schemas_TransactionInsert = TransactionInsert;
type schemas_TransactionUpdate = TransactionUpdate;
type schemas_TransactionDelete = TransactionDelete;
type schemas_TransactionResultInsert = TransactionResultInsert;
type schemas_TransactionResultUpdate = TransactionResultUpdate;
type schemas_TransactionResultDelete = TransactionResultDelete;
type schemas_TransactionError = TransactionError;
type schemas_User = User;
type schemas_UserID = UserID;
type schemas_UserWithID = UserWithID;
type schemas_APIKeyName = APIKeyName;
type schemas_WorkspaceID = WorkspaceID;
type schemas_Role = Role;
type schemas_WorkspaceMeta = WorkspaceMeta;
type schemas_Workspace = Workspace;
type schemas_WorkspaceMember = WorkspaceMember;
type schemas_InviteID = InviteID;
type schemas_WorkspaceInvite = WorkspaceInvite;
type schemas_WorkspaceMembers = WorkspaceMembers;
type schemas_InviteKey = InviteKey;
type schemas_DatabaseMetadata = DatabaseMetadata;
type schemas_ListDatabasesResponse = ListDatabasesResponse;
type schemas_ListRegionsResponse = ListRegionsResponse;
type schemas_Region = Region;
declare namespace schemas {
  export {
    schemas_BranchMetadata as BranchMetadata,
    schemas_BranchName as BranchName,
    schemas_DBName as DBName,
    schemas_DateTime as DateTime,
    schemas_MigrationStatus as MigrationStatus,
    schemas_DEPRECATEDDatabaseMetadata as DEPRECATEDDatabaseMetadata,
    schemas_DEPRECATEDListDatabasesResponse as DEPRECATEDListDatabasesResponse,
    schemas_ListBranchesResponse as ListBranchesResponse,
    schemas_ListGitBranchesResponse as ListGitBranchesResponse,
    schemas_Branch as Branch,
    schemas_DBBranch as DBBranch,
    schemas_StartedFromMetadata as StartedFromMetadata,
    schemas_Schema as Schema,
    schemas_SchemaEditScript as SchemaEditScript,
    schemas_Table as Table,
    schemas_Column as Column,
    schemas_ColumnLink as ColumnLink,
    schemas_RevLink as RevLink,
    schemas_DBBranchName as DBBranchName,
    schemas_TableName as TableName,
    schemas_ColumnName as ColumnName,
    schemas_MetricsDatapoint as MetricsDatapoint,
    schemas_MetricsLatency as MetricsLatency,
    schemas_BranchMigration as BranchMigration,
    schemas_TableMigration as TableMigration,
    schemas_ColumnMigration as ColumnMigration,
    schemas_Commit as Commit,
    schemas_Migration as Migration,
    schemas_MigrationOp as MigrationOp,
    schemas_MigrationTableOp as MigrationTableOp,
    schemas_MigrationColumnOp as MigrationColumnOp,
    schemas_TableOpAdd as TableOpAdd,
    schemas_TableOpRemove as TableOpRemove,
    schemas_TableOpRename as TableOpRename,
    schemas_ColumnOpAdd as ColumnOpAdd,
    schemas_ColumnOpRemove as ColumnOpRemove,
    schemas_ColumnOpRename as ColumnOpRename,
    schemas_MigrationRequestNumber as MigrationRequestNumber,
    schemas_MigrationRequest as MigrationRequest,
    schemas_SortExpression as SortExpression,
    schemas_SortOrder as SortOrder,
    schemas_FuzzinessExpression as FuzzinessExpression,
    schemas_PrefixExpression as PrefixExpression,
    schemas_TargetExpression as TargetExpression,
    schemas_FilterExpression as FilterExpression,
    schemas_SummaryExpressionList as SummaryExpressionList,
    schemas_SummaryExpression as SummaryExpression,
    schemas_AggExpressionMap as AggExpressionMap,
    schemas_AggExpression as AggExpression,
    schemas_CountAgg as CountAgg,
    schemas_SumAgg as SumAgg,
    schemas_MaxAgg as MaxAgg,
    schemas_MinAgg as MinAgg,
    schemas_AverageAgg as AverageAgg,
    schemas_UniqueCountAgg as UniqueCountAgg,
    schemas_DateHistogramAgg as DateHistogramAgg,
    schemas_TopValuesAgg as TopValuesAgg,
    schemas_NumericHistogramAgg as NumericHistogramAgg,
    schemas_HighlightExpression as HighlightExpression,
    schemas_BoosterExpression as BoosterExpression,
    ValueBooster$1 as ValueBooster,
    NumericBooster$1 as NumericBooster,
    DateBooster$1 as DateBooster,
    schemas_FilterList as FilterList,
    schemas_FilterColumn as FilterColumn,
    schemas_FilterColumnIncludes as FilterColumnIncludes,
    schemas_FilterPredicate as FilterPredicate,
    schemas_FilterPredicateOp as FilterPredicateOp,
    schemas_FilterPredicateRangeOp as FilterPredicateRangeOp,
    schemas_FilterRangeValue as FilterRangeValue,
    schemas_FilterValue as FilterValue,
    schemas_PageConfig as PageConfig,
    schemas_ColumnsProjection as ColumnsProjection,
    schemas_RecordMeta as RecordMeta,
    schemas_RecordID as RecordID,
    schemas_TableRename as TableRename,
    schemas_RecordsMetadata as RecordsMetadata,
    AggResponse$1 as AggResponse,
    schemas_TransactionOperation as TransactionOperation,
    schemas_TransactionInsert as TransactionInsert,
    schemas_TransactionUpdate as TransactionUpdate,
    schemas_TransactionDelete as TransactionDelete,
    schemas_TransactionResultInsert as TransactionResultInsert,
    schemas_TransactionResultUpdate as TransactionResultUpdate,
    schemas_TransactionResultDelete as TransactionResultDelete,
    schemas_TransactionError as TransactionError,
    XataRecord$1 as XataRecord,
    schemas_User as User,
    schemas_UserID as UserID,
    schemas_UserWithID as UserWithID,
    schemas_APIKeyName as APIKeyName,
    schemas_WorkspaceID as WorkspaceID,
    schemas_Role as Role,
    schemas_WorkspaceMeta as WorkspaceMeta,
    schemas_Workspace as Workspace,
    schemas_WorkspaceMember as WorkspaceMember,
    schemas_InviteID as InviteID,
    schemas_WorkspaceInvite as WorkspaceInvite,
    schemas_WorkspaceMembers as WorkspaceMembers,
    schemas_InviteKey as InviteKey,
    schemas_DatabaseMetadata as DatabaseMetadata,
    schemas_ListDatabasesResponse as ListDatabasesResponse,
    schemas_ListRegionsResponse as ListRegionsResponse,
    schemas_Region as Region,
  };
}

declare type ApiExtraProps = Omit<FetcherExtraProps, 'endpoint'>;
interface XataApiClientOptions {
    fetch?: FetchImpl;
    apiKey?: string;
    host?: HostProvider;
    trace?: TraceFunction;
}
declare class XataApiClient {
    #private;
    constructor(options?: XataApiClientOptions);
    get user(): UserApi;
    get authentication(): AuthenticationApi;
    get workspaces(): WorkspaceApi;
    get invites(): InvitesApi;
    get database(): DatabaseApi;
    get branches(): BranchApi;
    get migrations(): MigrationsApi;
    get migrationRequests(): MigrationRequestsApi;
    get tables(): TableApi;
    get records(): RecordsApi;
    get searchAndFilter(): SearchAndFilterApi;
}
declare class UserApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    getUser(): Promise<UserWithID>;
    updateUser({ user }: {
        user: User;
    }): Promise<UserWithID>;
    deleteUser(): Promise<void>;
}
declare class AuthenticationApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    getUserAPIKeys(): Promise<GetUserAPIKeysResponse>;
    createUserAPIKey({ name }: {
        name: APIKeyName;
    }): Promise<CreateUserAPIKeyResponse>;
    deleteUserAPIKey({ name }: {
        name: APIKeyName;
    }): Promise<void>;
}
declare class WorkspaceApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    getWorkspacesList(): Promise<GetWorkspacesListResponse>;
    createWorkspace({ data }: {
        data: WorkspaceMeta;
    }): Promise<Workspace>;
    getWorkspace({ workspace }: {
        workspace: WorkspaceID;
    }): Promise<Workspace>;
    updateWorkspace({ workspace, update }: {
        workspace: WorkspaceID;
        update: WorkspaceMeta;
    }): Promise<Workspace>;
    deleteWorkspace({ workspace }: {
        workspace: WorkspaceID;
    }): Promise<void>;
    getWorkspaceMembersList({ workspace }: {
        workspace: WorkspaceID;
    }): Promise<WorkspaceMembers>;
    updateWorkspaceMemberRole({ workspace, user, role }: {
        workspace: WorkspaceID;
        user: UserID;
        role: Role;
    }): Promise<void>;
    removeWorkspaceMember({ workspace, user }: {
        workspace: WorkspaceID;
        user: UserID;
    }): Promise<void>;
}
declare class InvitesApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    inviteWorkspaceMember({ workspace, email, role }: {
        workspace: WorkspaceID;
        email: string;
        role: Role;
    }): Promise<WorkspaceInvite>;
    updateWorkspaceMemberInvite({ workspace, invite, role }: {
        workspace: WorkspaceID;
        invite: InviteID;
        role: Role;
    }): Promise<WorkspaceInvite>;
    cancelWorkspaceMemberInvite({ workspace, invite }: {
        workspace: WorkspaceID;
        invite: InviteID;
    }): Promise<void>;
    acceptWorkspaceMemberInvite({ workspace, key }: {
        workspace: WorkspaceID;
        key: InviteKey;
    }): Promise<void>;
    resendWorkspaceMemberInvite({ workspace, invite }: {
        workspace: WorkspaceID;
        invite: InviteID;
    }): Promise<void>;
}
declare class BranchApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    getBranchList({ workspace, region, database }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
    }): Promise<ListBranchesResponse>;
    getBranchDetails({ workspace, region, database, branch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
    }): Promise<DBBranch>;
    createBranch({ workspace, region, database, branch, from, metadata }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        from?: string;
        metadata?: BranchMetadata;
    }): Promise<CreateBranchResponse>;
    deleteBranch({ workspace, region, database, branch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
    }): Promise<DeleteBranchResponse>;
    updateBranchMetadata({ workspace, region, database, branch, metadata }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        metadata: BranchMetadata;
    }): Promise<void>;
    getBranchMetadata({ workspace, region, database, branch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
    }): Promise<BranchMetadata>;
    getBranchStats({ workspace, region, database, branch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
    }): Promise<GetBranchStatsResponse>;
    getGitBranchesMapping({ workspace, region, database }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
    }): Promise<ListGitBranchesResponse>;
    addGitBranchesEntry({ workspace, region, database, gitBranch, xataBranch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        gitBranch: string;
        xataBranch: BranchName;
    }): Promise<AddGitBranchesEntryResponse>;
    removeGitBranchesEntry({ workspace, region, database, gitBranch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        gitBranch: string;
    }): Promise<void>;
    resolveBranch({ workspace, region, database, gitBranch, fallbackBranch }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        gitBranch?: string;
        fallbackBranch?: string;
    }): Promise<ResolveBranchResponse>;
}
declare class TableApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    createTable({ workspace, region, database, branch, table }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
    }): Promise<CreateTableResponse>;
    deleteTable({ workspace, region, database, branch, table }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
    }): Promise<DeleteTableResponse>;
    updateTable({ workspace, region, database, branch, table, update }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        update: UpdateTableRequestBody;
    }): Promise<SchemaUpdateResponse>;
    getTableSchema({ workspace, region, database, branch, table }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
    }): Promise<GetTableSchemaResponse>;
    setTableSchema({ workspace, region, database, branch, table, schema }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        schema: SetTableSchemaRequestBody;
    }): Promise<SchemaUpdateResponse>;
    getTableColumns({ workspace, region, database, branch, table }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
    }): Promise<GetTableColumnsResponse>;
    addTableColumn({ workspace, region, database, branch, table, column }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        column: Column;
    }): Promise<SchemaUpdateResponse>;
    getColumn({ workspace, region, database, branch, table, column }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        column: ColumnName;
    }): Promise<Column>;
    updateColumn({ workspace, region, database, branch, table, column, update }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        column: ColumnName;
        update: UpdateColumnRequestBody;
    }): Promise<SchemaUpdateResponse>;
    deleteColumn({ workspace, region, database, branch, table, column }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        column: ColumnName;
    }): Promise<SchemaUpdateResponse>;
}
declare class RecordsApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    insertRecord({ workspace, region, database, branch, table, record, columns }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        record: Record<string, any>;
        columns?: ColumnsProjection;
    }): Promise<RecordUpdateResponse>;
    getRecord({ workspace, region, database, branch, table, id, columns }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        id: RecordID;
        columns?: ColumnsProjection;
    }): Promise<XataRecord$1>;
    insertRecordWithID({ workspace, region, database, branch, table, id, record, columns, createOnly, ifVersion }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        id: RecordID;
        record: Record<string, any>;
        columns?: ColumnsProjection;
        createOnly?: boolean;
        ifVersion?: number;
    }): Promise<RecordUpdateResponse>;
    updateRecordWithID({ workspace, region, database, branch, table, id, record, columns, ifVersion }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        id: RecordID;
        record: Record<string, any>;
        columns?: ColumnsProjection;
        ifVersion?: number;
    }): Promise<RecordUpdateResponse>;
    upsertRecordWithID({ workspace, region, database, branch, table, id, record, columns, ifVersion }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        id: RecordID;
        record: Record<string, any>;
        columns?: ColumnsProjection;
        ifVersion?: number;
    }): Promise<RecordUpdateResponse>;
    deleteRecord({ workspace, region, database, branch, table, id, columns }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        id: RecordID;
        columns?: ColumnsProjection;
    }): Promise<RecordUpdateResponse>;
    bulkInsertTableRecords({ workspace, region, database, branch, table, records, columns }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        records: Record<string, any>[];
        columns?: ColumnsProjection;
    }): Promise<BulkInsertResponse>;
}
declare class SearchAndFilterApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    queryTable({ workspace, region, database, branch, table, filter, sort, page, columns, consistency }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        filter?: FilterExpression;
        sort?: SortExpression;
        page?: PageConfig;
        columns?: ColumnsProjection;
        consistency?: 'strong' | 'eventual';
    }): Promise<QueryResponse>;
    searchTable({ workspace, region, database, branch, table, query, fuzziness, target, prefix, filter, highlight, boosters }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        query: string;
        fuzziness?: FuzzinessExpression;
        target?: TargetExpression;
        prefix?: PrefixExpression;
        filter?: FilterExpression;
        highlight?: HighlightExpression;
        boosters?: BoosterExpression[];
    }): Promise<SearchResponse>;
    searchBranch({ workspace, region, database, branch, tables, query, fuzziness, prefix, highlight }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        tables?: (string | {
            table: string;
            filter?: FilterExpression;
            target?: TargetExpression;
            boosters?: BoosterExpression[];
        })[];
        query: string;
        fuzziness?: FuzzinessExpression;
        prefix?: PrefixExpression;
        highlight?: HighlightExpression;
    }): Promise<SearchResponse>;
    summarizeTable({ workspace, region, database, branch, table, filter, columns, summaries, sort, summariesFilter, page, consistency }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        filter?: FilterExpression;
        columns?: ColumnsProjection;
        summaries?: SummaryExpressionList;
        sort?: SortExpression;
        summariesFilter?: FilterExpression;
        page?: {
            size?: number;
        };
        consistency?: 'strong' | 'eventual';
    }): Promise<SummarizeResponse>;
    aggregateTable({ workspace, region, database, branch, table, filter, aggs }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        table: TableName;
        filter?: FilterExpression;
        aggs?: AggExpressionMap;
    }): Promise<AggResponse>;
}
declare class MigrationRequestsApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    queryMigrationRequests({ workspace, region, database, filter, sort, page, columns }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        filter?: FilterExpression;
        sort?: SortExpression;
        page?: PageConfig;
        columns?: ColumnsProjection;
    }): Promise<QueryMigrationRequestsResponse>;
    createMigrationRequest({ workspace, region, database, migration }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migration: CreateMigrationRequestRequestBody;
    }): Promise<CreateMigrationRequestResponse>;
    getMigrationRequest({ workspace, region, database, migrationRequest }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migrationRequest: MigrationRequestNumber;
    }): Promise<MigrationRequest>;
    updateMigrationRequest({ workspace, region, database, migrationRequest, update }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migrationRequest: MigrationRequestNumber;
        update: UpdateMigrationRequestRequestBody;
    }): Promise<void>;
    listMigrationRequestsCommits({ workspace, region, database, migrationRequest, page }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migrationRequest: MigrationRequestNumber;
        page?: {
            after?: string;
            before?: string;
            size?: number;
        };
    }): Promise<ListMigrationRequestsCommitsResponse>;
    compareMigrationRequest({ workspace, region, database, migrationRequest }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migrationRequest: MigrationRequestNumber;
    }): Promise<SchemaCompareResponse>;
    getMigrationRequestIsMerged({ workspace, region, database, migrationRequest }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migrationRequest: MigrationRequestNumber;
    }): Promise<GetMigrationRequestIsMergedResponse>;
    mergeMigrationRequest({ workspace, region, database, migrationRequest }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        migrationRequest: MigrationRequestNumber;
    }): Promise<Commit>;
}
declare class MigrationsApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    getBranchMigrationHistory({ workspace, region, database, branch, limit, startFrom }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        limit?: number;
        startFrom?: string;
    }): Promise<GetBranchMigrationHistoryResponse>;
    getBranchMigrationPlan({ workspace, region, database, branch, schema }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        schema: Schema;
    }): Promise<BranchMigrationPlan>;
    executeBranchMigrationPlan({ workspace, region, database, branch, plan }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        plan: ExecuteBranchMigrationPlanRequestBody;
    }): Promise<SchemaUpdateResponse>;
    getBranchSchemaHistory({ workspace, region, database, branch, page }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        page?: {
            after?: string;
            before?: string;
            size?: number;
        };
    }): Promise<GetBranchSchemaHistoryResponse>;
    compareBranchWithUserSchema({ workspace, region, database, branch, schema }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        schema: Schema;
    }): Promise<SchemaCompareResponse>;
    compareBranchSchemas({ workspace, region, database, branch, compare, schema }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        compare: BranchName;
        schema: Schema;
    }): Promise<SchemaCompareResponse>;
    updateBranchSchema({ workspace, region, database, branch, migration }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        migration: Migration;
    }): Promise<SchemaUpdateResponse>;
    previewBranchSchemaEdit({ workspace, region, database, branch, data }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        data: {
            edits?: SchemaEditScript;
        };
    }): Promise<PreviewBranchSchemaEditResponse>;
    applyBranchSchemaEdit({ workspace, region, database, branch, edits }: {
        workspace: WorkspaceID;
        region: string;
        database: DBName;
        branch: BranchName;
        edits: SchemaEditScript;
    }): Promise<SchemaUpdateResponse>;
}
declare class DatabaseApi {
    private extraProps;
    constructor(extraProps: ApiExtraProps);
    getDatabaseList({ workspace }: {
        workspace: WorkspaceID;
    }): Promise<ListDatabasesResponse>;
    createDatabase({ workspace, database, data }: {
        workspace: WorkspaceID;
        database: DBName;
        data: CreateDatabaseRequestBody;
    }): Promise<CreateDatabaseResponse>;
    deleteDatabase({ workspace, database }: {
        workspace: WorkspaceID;
        database: DBName;
    }): Promise<DeleteDatabaseResponse>;
    getDatabaseMetadata({ workspace, database }: {
        workspace: WorkspaceID;
        database: DBName;
    }): Promise<DatabaseMetadata>;
    updateDatabaseMetadata({ workspace, database, metadata }: {
        workspace: WorkspaceID;
        database: DBName;
        metadata: DatabaseMetadata;
    }): Promise<DatabaseMetadata>;
    listRegions({ workspace }: {
        workspace: WorkspaceID;
    }): Promise<ListRegionsResponse>;
}

declare class XataApiPlugin implements XataPlugin {
    build(options: XataPluginOptions): Promise<XataApiClient>;
}

declare type StringKeys<O> = Extract<keyof O, string>;
declare type Values<O> = O[StringKeys<O>];
declare type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never;
declare type If<Condition, Then, Else> = Condition extends true ? Then : Else;
declare type IsObject<T> = T extends Record<string, any> ? true : false;
declare type IsArray<T> = T extends Array<any> ? true : false;
declare type RequiredBy<T, K extends keyof T> = T & {
    [P in K]-?: NonNullable<T[P]>;
};
declare type GetArrayInnerType<T extends readonly any[]> = T[number];
declare type SingleOrArray<T> = T | T[];
declare type Dictionary<T> = Record<string, T>;
declare type OmitBy<T, K extends keyof T> = T extends any ? Omit<T, K> : never;
declare type Without<T, U> = {
    [P in Exclude<keyof T, keyof U>]?: never;
};
declare type ExclusiveOr<T, U> = T | U extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;
declare type Explode<T> = keyof T extends infer K ? K extends unknown ? {
    [I in keyof T]: I extends K ? T[I] : never;
} : never : never;
declare type AtMostOne<T> = Explode<Partial<T>>;
declare type AtLeastOne<T, U = {
    [K in keyof T]: Pick<T, K>;
}> = Partial<T> & U[keyof U];
declare type ExactlyOne<T> = AtMostOne<T> & AtLeastOne<T>;

declare type SelectableColumn<O, RecursivePath extends any[] = []> = '*' | 'id' | DataProps<O> | NestedColumns<O, RecursivePath>;
declare type WildcardColumns<O> = Values<{
    [K in SelectableColumn<O>]: K extends `${string}*` ? K : never;
}>;
declare type ColumnsByValue<O, Value> = Values<{
    [K in SelectableColumn<O>]: ValueAtColumn<O, K> extends infer C ? C extends Value ? K extends WildcardColumns<O> ? never : K : never : never;
}>;
declare type SelectedPick<O extends XataRecord, Key extends SelectableColumn<O>[]> = XataRecord<O> & UnionToIntersection<Values<{
    [K in Key[number]]: NestedValueAtColumn<O, K> & XataRecord<O>;
}>>;
declare type ValueAtColumn<O, P extends SelectableColumn<O>> = P extends '*' ? Values<O> : P extends 'id' ? string : P extends keyof O ? O[P] : P extends `${infer K}.${infer V}` ? K extends keyof O ? Values<NonNullable<O[K]> extends infer Item ? Item extends Record<string, any> ? V extends SelectableColumn<Item> ? {
    V: ValueAtColumn<Item, V>;
} : never : O[K] : never> : never : never;
declare type MAX_RECURSION = 5;
declare type NestedColumns<O, RecursivePath extends any[]> = RecursivePath['length'] extends MAX_RECURSION ? never : If<IsObject<O>, Values<{
    [K in DataProps<O>]: NonNullable<O[K]> extends infer Item ? If<IsArray<Item>, K, // If the property is an array, we stop recursion. We don't support object arrays yet
    If<IsObject<Item>, Item extends XataRecord ? SelectableColumn<Item, [...RecursivePath, Item]> extends infer Column ? Column extends string ? K | `${K}.${Column}` : never : never : Item extends Date ? K : `${K}.${StringKeys<Item> | '*'}`, // This allows usage of objects that are not links
    K>> : never;
}>, never>;
declare type DataProps<O> = Exclude<StringKeys<O>, StringKeys<XataRecord>>;
declare type NestedValueAtColumn<O, Key extends SelectableColumn<O>> = Key extends `${infer N}.${infer M}` ? N extends DataProps<O> ? {
    [K in N]: M extends SelectableColumn<NonNullable<O[K]>> ? NonNullable<O[K]> extends XataRecord ? ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M> & XataRecord> : ForwardNullable<O[K], NestedValueAtColumn<NonNullable<O[K]>, M>> : unknown;
} : unknown : Key extends DataProps<O> ? {
    [K in Key]: NonNullable<O[K]> extends XataRecord ? ForwardNullable<O[K], SelectedPick<NonNullable<O[K]>, ['*']>> : O[K];
} : Key extends '*' ? {
    [K in StringKeys<O>]: NonNullable<O[K]> extends XataRecord ? ForwardNullable<O[K], Link<NonNullable<O[K]>>> : O[K];
} : unknown;
declare type ForwardNullable<T, R> = T extends NonNullable<T> ? R : R | null;

/**
 * Represents an identifiable record from the database.
 */
interface Identifiable {
    /**
     * Unique id of this record.
     */
    id: string;
}
interface BaseData {
    [key: string]: any;
}
/**
 * Represents a persisted record from the database.
 */
interface XataRecord<OriginalRecord extends XataRecord<any> = XataRecord<any>> extends Identifiable {
    /**
     * Get metadata of this record.
     */
    getMetadata(): XataRecordMetadata;
    /**
     * Retrieves a refreshed copy of the current record from the database.
     * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.
     * @returns The persisted record with the selected columns, null if not found.
     */
    read<K extends SelectableColumn<OriginalRecord>>(columns: K[]): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;
    /**
     * Retrieves a refreshed copy of the current record from the database.
     * @returns The persisted record with all first level properties, null if not found.
     */
    read(): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;
    /**
     * Performs a partial update of the current record. On success a new object is
     * returned and the current object is not mutated.
     * @param partialUpdate The columns and their values that have to be updated.
     * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.
     * @returns The persisted record with the selected columns, null if not found.
     */
    update<K extends SelectableColumn<OriginalRecord>>(partialUpdate: Partial<EditableData<OriginalRecord>>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;
    /**
     * Performs a partial update of the current record. On success a new object is
     * returned and the current object is not mutated.
     * @param partialUpdate The columns and their values that have to be updated.
     * @returns The persisted record with all first level properties, null if not found.
     */
    update(partialUpdate: Partial<EditableData<OriginalRecord>>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;
    /**
     * Performs a replace of the current record. On success a new object is
     * returned and the current object is not mutated.
     * @param partialUpdate The columns and their values that have to be updated.
     * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.
     * @returns The persisted record with the selected columns, null if not found.
     */
    replace<K extends SelectableColumn<OriginalRecord>>(object: Partial<EditableData<OriginalRecord>>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;
    /**
     * Performs a replace of the current record. On success a new object is
     * returned and the current object is not mutated.
     * @param partialUpdate The columns and their values that have to be updated.
     * @returns The persisted record with all first level properties, null if not found.
     */
    replace(object: Partial<EditableData<OriginalRecord>>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;
    /**
     * Performs a deletion of the current record in the database.
     * @param columns The columns to retrieve. If not specified, all first level properties are retrieved.
     * @returns The deleted record, null if not found.
     */
    delete<K extends SelectableColumn<OriginalRecord>>(columns: K[]): Promise<Readonly<SelectedPick<OriginalRecord, typeof columns>> | null>;
    /**
     * Performs a deletion of the current record in the database.
     * @returns The deleted record, null if not found.
  
     */
    delete(): Promise<Readonly<SelectedPick<OriginalRecord, ['*']>> | null>;
}
declare type Link<Record extends XataRecord> = XataRecord<Record>;
declare type XataRecordMetadata = {
    /**
     * Number that is increased every time the record is updated.
     */
    version: number;
    warnings?: string[];
};
declare function isIdentifiable(x: any): x is Identifiable & Record<string, unknown>;
declare function isXataRecord(x: any): x is XataRecord & Record<string, unknown>;
declare type EditableData<O extends XataRecord> = Identifiable & Partial<Omit<{
    [K in keyof O]: O[K] extends XataRecord ? {
        id: string;
    } | string : NonNullable<O[K]> extends XataRecord ? {
        id: string;
    } | string | null | undefined : O[K];
}, keyof XataRecord>>;

/**
 * PropertyMatchFilter
 * Example:
{
  "filter": {
    "name": "value",
    "name": {
       "$is":  "value",
       "$any": [ "value1", "value2" ],
    },
    "settings.plan": {"$any": ["free", "paid"]},
    "settings.plan": "free",
    "settings": {
      "plan": "free"
    },
  }
}
*/
declare type PropertyAccessFilter<Record> = {
    [key in ColumnsByValue<Record, any>]?: NestedApiFilter<ValueAtColumn<Record, key>> | PropertyFilter<ValueAtColumn<Record, key>>;
};
declare type PropertyFilter<T> = T | {
    $is: T;
} | {
    $isNot: T;
} | {
    $any: T[];
} | {
    $none: T[];
} | ValueTypeFilters<T>;
declare type IncludesFilter<T> = PropertyFilter<T> | {
    [key in '$all' | '$none' | '$any']?: IncludesFilter<T> | Array<IncludesFilter<T> | {
        $not: IncludesFilter<T>;
    }>;
};
declare type StringTypeFilter = {
    [key in '$contains' | '$pattern' | '$startsWith' | '$endsWith']?: string;
};
declare type ComparableType = number | Date;
declare type ComparableTypeFilter<T extends ComparableType> = {
    [key in '$gt' | '$lt' | '$ge' | '$le']?: T;
};
declare type ArrayFilter<T> = {
    [key in '$includes']?: SingleOrArray<PropertyFilter<T> | ValueTypeFilters<T>> | IncludesFilter<T>;
} | {
    [key in '$includesAll' | '$includesNone' | '$includesAny']?: T | Array<PropertyFilter<T> | {
        $not: PropertyFilter<T>;
    }>;
};
declare type ValueTypeFilters<T> = T | T extends string ? StringTypeFilter : T extends number ? ComparableTypeFilter<number> : T extends Date ? ComparableTypeFilter<Date> : T extends Array<infer T> ? ArrayFilter<T> : never;
/**
 * AggregatorFilter
 * Example:
{
  "filter": {
      "$any": {
        "settings.dark": true,
        "settings.plan": "free"
      }
  },
}
{
  "filter": {
    "$any": [
      {
        "name": "r1",
      },
      {
        "name": "r2",
      },
    ],
}
*/
declare type AggregatorFilter<T> = {
    [key in '$all' | '$any' | '$not' | '$none']?: SingleOrArray<Filter<T>>;
};
/**
 * Existance filter
 * Example: { filter: { $exists: "settings" } }
 */
declare type ExistanceFilter<Record> = {
    [key in '$exists' | '$notExists']?: ColumnsByValue<Record, any>;
};
declare type BaseApiFilter<Record> = PropertyAccessFilter<Record> | AggregatorFilter<Record> | ExistanceFilter<Record>;
/**
 * Nested filter
 * Injects the Api filters on nested properties
 * Example: { filter: { settings: { plan: { $any: ['free', 'trial'] } } } }
 */
declare type NestedApiFilter<T> = {
    [key in keyof T]?: T[key] extends Record<string, any> ? SingleOrArray<Filter<T[key]>> : PropertyFilter<T[key]>;
};
declare type Filter<T> = T extends Record<string, any> ? T extends (infer ArrayType)[] ? ArrayType | ArrayType[] | ArrayFilter<ArrayType> | ArrayFilter<ArrayType[]> : T extends Date ? PropertyFilter<T> : BaseApiFilter<T> | NestedApiFilter<T> : PropertyFilter<T>;

declare type DateBooster = {
    origin?: string;
    scale: string;
    decay: number;
};
declare type NumericBooster = {
    factor: number;
};
declare type ValueBooster<T extends string | number | boolean> = {
    value: T;
    factor: number;
};
declare type Boosters<O extends XataRecord> = Values<{
    [K in SelectableColumn<O>]: NonNullable<ValueAtColumn<O, K>> extends Date ? {
        dateBooster: {
            column: K;
        } & DateBooster;
    } : NonNullable<ValueAtColumn<O, K>> extends number ? ExclusiveOr<{
        numericBooster?: {
            column: K;
        } & NumericBooster;
    }, {
        valueBooster?: {
            column: K;
        } & ValueBooster<number>;
    }> : NonNullable<ValueAtColumn<O, K>> extends string | boolean ? {
        valueBooster: {
            column: K;
        } & ValueBooster<NonNullable<ValueAtColumn<O, K>>>;
    } : never;
}>;

declare type TargetColumn<T extends XataRecord> = SelectableColumn<T> | {
    /**
     * The name of the column.
     */
    column: SelectableColumn<T>;
    /**
     * The weight of the column.
     *
     * @default 1
     * @maximum 10
     * @minimum 1
     */
    weight?: number;
};

declare type SearchOptions<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>> = {
    fuzziness?: FuzzinessExpression;
    prefix?: PrefixExpression;
    highlight?: HighlightExpression;
    tables?: Array<Tables | Values<{
        [Model in GetArrayInnerType<NonNullable<Tables[]>>]: {
            table: Model;
            target?: TargetColumn<Schemas[Model] & XataRecord>[];
            filter?: Filter<SelectedPick<Schemas[Model] & XataRecord, ['*']>>;
            boosters?: Boosters<Schemas[Model] & XataRecord>[];
        };
    }>>;
};
declare type SearchPluginResult<Schemas extends Record<string, BaseData>> = {
    all: <Tables extends StringKeys<Schemas>>(query: string, options?: SearchOptions<Schemas, Tables>) => Promise<Values<{
        [Model in ExtractTables<Schemas, Tables, GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>>]: {
            table: Model;
            record: Awaited<SearchXataRecord<SelectedPick<Schemas[Model] & XataRecord, ['*']>>>;
        };
    }>[]>;
    byTable: <Tables extends StringKeys<Schemas>>(query: string, options?: SearchOptions<Schemas, Tables>) => Promise<{
        [Model in ExtractTables<Schemas, Tables, GetArrayInnerType<NonNullable<NonNullable<typeof options>['tables']>>>]?: Awaited<SearchXataRecord<SelectedPick<Schemas[Model] & XataRecord, ['*']>>[]>;
    }>;
};
declare class SearchPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {
    #private;
    private db;
    constructor(db: SchemaPluginResult<Schemas>, schemaTables?: Schemas.Table[]);
    build({ getFetchProps }: XataPluginOptions): SearchPluginResult<Schemas>;
}
declare type SearchXataRecord<Record extends XataRecord> = Omit<Record, 'getMetadata'> & {
    getMetadata: () => XataRecordMetadata & SearchExtraProperties;
};
declare type SearchExtraProperties = {
    table: string;
    highlight?: {
        [key: string]: string[] | {
            [key: string]: any;
        };
    };
    score?: number;
};
declare type ReturnTable<Table, Tables> = Table extends Tables ? Table : never;
declare type ExtractTables<Schemas extends Record<string, BaseData>, Tables extends StringKeys<Schemas>, TableOptions extends GetArrayInnerType<NonNullable<NonNullable<SearchOptions<Schemas, Tables>>['tables']>>> = TableOptions extends `${infer Table}` ? ReturnTable<Table, Tables> : TableOptions extends {
    table: infer Table;
} ? ReturnTable<Table, Tables> : never;

/**
 * The description of a single aggregation operation. The key represents the
 */
declare type AggregationExpression<O extends XataRecord> = ExactlyOne<{
    count: CountAggregation<O>;
    sum: SumAggregation<O>;
    max: MaxAggregation<O>;
    min: MinAggregation<O>;
    average: AverageAggregation<O>;
    uniqueCount: UniqueCountAggregation<O>;
    dateHistogram: DateHistogramAggregation<O>;
    topValues: TopValuesAggregation<O>;
    numericHistogram: NumericHistogramAggregation<O>;
}>;
declare type AggregationResult<Record extends XataRecord, Expression extends Dictionary<AggregationExpression<Record>>> = {
    aggs: {
        [K in keyof Expression]: AggregationResultItem<Record, Expression[K]>;
    };
};
declare type AggregationExpressionType<T extends AggregationExpression<any>> = keyof T;
declare type AggregationResultItem<Record extends XataRecord, Expression extends AggregationExpression<Record>> = AggregationExpressionType<Expression> extends infer Type ? Type extends keyof AggregationExpressionResultTypes ? AggregationExpressionResultTypes[Type] : never : never;
/**
 * Count the number of records with an optional filter.
 */
declare type CountAggregation<O extends XataRecord> = {
    filter?: Filter<O>;
} | '*';
/**
 * The sum of the numeric values in a particular column.
 */
declare type SumAggregation<O extends XataRecord> = {
    /**
     * The column on which to compute the sum. Must be a numeric type.
     */
    column: ColumnsByValue<O, number>;
};
/**
 * The max of the numeric values in a particular column.
 */
declare type MaxAggregation<O extends XataRecord> = {
    /**
     * The column on which to compute the max. Must be a numeric type.
     */
    column: ColumnsByValue<O, number>;
};
/**
 * The min of the numeric values in a particular column.
 */
declare type MinAggregation<O extends XataRecord> = {
    /**
     * The column on which to compute the min. Must be a numeric type.
     */
    column: ColumnsByValue<O, number>;
};
/**
 * The average of the numeric values in a particular column.
 */
declare type AverageAggregation<O extends XataRecord> = {
    /**
     * The column on which to compute the average. Must be a numeric type.
     */
    column: ColumnsByValue<O, number>;
};
/**
 * Count the number of distinct values in a particular column.
 */
declare type UniqueCountAggregation<O extends XataRecord> = {
    /**
     * The column from where to count the unique values.
     */
    column: ColumnsByValue<O, any>;
    /**
     * The threshold under which the unique count is exact. If the number of unique
     * values in the column is higher than this threshold, the results are approximative.
     * Maximum value is 40,000, default value is 3000.
     */
    precisionThreshold?: number;
};
/**
 * Split data into buckets by a datetime column. Accepts sub-aggregations for each bucket.
 */
declare type DateHistogramAggregation<O extends XataRecord> = {
    /**
     * The column to use for bucketing. Must be of type datetime.
     */
    column: ColumnsByValue<O, Date>;
    /**
     * The fixed interval to use when bucketing.
     * It is fromatted as number + units, for example: `5d`, `20m`, `10s`.
     *
     * @pattern ^(\d+)(d|h|m|s|ms)$
     */
    interval?: string;
    /**
     * The calendar-aware interval to use when bucketing. Possible values are: `minute`,
     * `hour`, `day`, `week`, `month`, `quarter`, `year`.
     */
    calendarInterval?: 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';
    /**
     * The timezone to use for bucketing. By default, UTC is assumed.
     * The accepted format is as an ISO 8601 UTC offset. For example: `+01:00` or
     * `-08:00`.
     *
     * @pattern ^[+-][01]\d:[0-5]\d$
     */
    timezone?: string;
    aggs?: Dictionary<AggregationExpression<O>>;
};
/**
 * Split data into buckets by the unique values in a column. Accepts sub-aggregations for each bucket.
 * The top values as ordered by the number of records (`$count``) are returned.
 */
declare type TopValuesAggregation<O extends XataRecord> = {
    /**
     * The column to use for bucketing. Accepted types are `string`, `email`, `int`, `float`, or `bool`.
     */
    column: ColumnsByValue<O, string | number | boolean>;
    aggs?: Dictionary<AggregationExpression<O>>;
    /**
     * The maximum number of unique values to return.
     *
     * @default 10
     * @maximum 1000
     */
    size?: number;
};
/**
 * Split data into buckets by dynamic numeric ranges. Accepts sub-aggregations for each bucket.
 */
declare type NumericHistogramAggregation<O extends XataRecord> = {
    /**
     * The column to use for bucketing. Must be of numeric type.
     */
    column: ColumnsByValue<O, number>;
    /**
     * The numeric interval to use for bucketing. The resulting buckets will be ranges
     * with this value as size.
     *
     * @minimum 0
     */
    interval: number;
    /**
     * By default the bucket keys start with 0 and then continue in `interval` steps. The bucket
     * boundaries can be shiftend by using the offset option. For example, if the `interval` is 100,
     * but you prefer the bucket boundaries to be `[50, 150), [150, 250), etc.`, you can set `offset`
     * to 50.
     *
     * @default 0
     */
    offset?: number;
    aggs?: Dictionary<AggregationExpression<O>>;
};
declare type AggregationExpressionResultTypes = {
    count: number;
    sum: number | null;
    max: number | null;
    min: number | null;
    average: number | null;
    uniqueCount: number;
    dateHistogram: ComplexAggregationResult;
    topValues: ComplexAggregationResult;
    numericHistogram: ComplexAggregationResult;
};
declare type ComplexAggregationResult = {
    values: Array<{
        $key: string | number;
        $count: number;
        [key: string]: any;
    }>;
};

declare type SortDirection = 'asc' | 'desc';
declare type SortFilterExtended<T extends XataRecord, Columns extends string = ColumnsByValue<T, any>> = {
    column: Columns;
    direction?: SortDirection;
};
declare type SortFilter<T extends XataRecord, Columns extends string = ColumnsByValue<T, any>> = Columns | SortFilterExtended<T, Columns> | SortFilterBase<T, Columns>;
declare type SortFilterBase<T extends XataRecord, Columns extends string = ColumnsByValue<T, any>> = Values<{
    [Key in Columns]: {
        [K in Key]: SortDirection;
    };
}>;

declare type SummarizeExpression<O extends XataRecord> = ExactlyOne<{
    count: ColumnsByValue<O, any> | '*';
    min: ColumnsByValue<O, string | number | Date | any[]>;
    max: ColumnsByValue<O, string | number | Date | any[]>;
    sum: ColumnsByValue<O, number>;
    average: ColumnsByValue<O, number>;
}>;
declare type SummarizeParams<Record extends XataRecord, Expression extends Dictionary<SummarizeExpression<Record>>, Columns extends SelectableColumn<Record>[]> = {
    summaries?: Expression;
    summariesFilter?: SummarizeFilter<Record, Expression>;
    filter?: Filter<Record>;
    columns?: Columns;
    sort?: SummarizeSort<Record, Expression>;
    pagination?: {
        size: number;
    };
};
declare type SummarizeResult<Record extends XataRecord, Expression extends Dictionary<SummarizeExpression<Record>>, Columns extends SelectableColumn<Record>[]> = {
    summaries: SummarizeResultItem<Record, Expression, Columns>[];
};
declare type SummarizeExpressionResultTypes<Value> = {
    count: number;
    min: Value;
    max: Value;
    sum: number;
    average: number;
};
declare type SummarizeSort<Record extends XataRecord, Expression extends Dictionary<SummarizeExpression<Record>>> = SingleOrArray<SortFilter<Record, ColumnsByValue<Record, any> | StringKeys<Expression>>>;
declare type SummarizeValuePick<Record extends XataRecord, Expression extends Dictionary<SummarizeExpression<Record>>> = {
    [K in StringKeys<Expression>]: StringKeys<Expression[K]> extends infer SummarizeOperation ? SummarizeOperation extends keyof Expression[K] ? Expression[K][SummarizeOperation] extends infer Column ? Column extends SelectableColumn<Record> ? SummarizeOperation extends keyof SummarizeExpressionResultTypes<any> ? SummarizeExpressionResultTypes<ValueAtColumn<Record, Column>>[SummarizeOperation] : never : never : never : never : never;
};
declare type SummarizeFilter<Record extends XataRecord, Expression extends Dictionary<SummarizeExpression<Record>>> = Filter<Record & SummarizeValuePick<Record, Expression>>;
declare type SummarizeResultItem<Record extends XataRecord, Expression extends Dictionary<SummarizeExpression<Record>>, Columns extends SelectableColumn<Record>[]> = SummarizeValuePick<Record, Expression> & SelectedPick<Record, Columns>;

declare type BaseOptions<T extends XataRecord> = {
    columns?: SelectableColumn<T>[];
    cache?: number;
    fetchOptions?: Record<string, unknown>;
};
declare type CursorQueryOptions = {
    pagination?: CursorNavigationOptions & OffsetNavigationOptions;
    filter?: never;
    sort?: never | unknown;
};
declare type OffsetQueryOptions<T extends XataRecord> = {
    pagination?: OffsetNavigationOptions;
    filter?: FilterExpression;
    sort?: SingleOrArray<SortFilter<T>>;
};
declare type QueryOptions<T extends XataRecord> = BaseOptions<T> & (CursorQueryOptions | OffsetQueryOptions<T>);
/**
 * Query objects contain the information of all filters, sorting, etc. to be included in the database query.
 *
 * Query objects are immutable. Any method that adds more constraints or options to the query will return
 * a new Query object containing the both the previous and the new constraints and options.
 */
declare class Query<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {
    #private;
    readonly meta: PaginationQueryMeta;
    readonly records: RecordArray<Result>;
    constructor(repository: RestRepository<Record> | null, table: {
        name: string;
        schema?: Table;
    }, data: Partial<QueryOptions<Record>>, rawParent?: Partial<QueryOptions<Record>>);
    getQueryOptions(): QueryOptions<Record>;
    key(): string;
    /**
     * Builds a new query object representing a logical OR between the given subqueries.
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    any(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object representing a logical AND between the given subqueries.
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    all(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object representing a logical OR negating each subquery. In pseudo-code: !q1 OR !q2
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    not(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object representing a logical AND negating each subquery. In pseudo-code: !q1 AND !q2
     * @param queries An array of subqueries.
     * @returns A new Query object.
     */
    none(...queries: Query<Record, any>[]): Query<Record, Result>;
    /**
     * Builds a new query object adding one or more constraints. Examples:
     *
     * ```
     * query.filter("columnName", columnValue)
     * query.filter("columnName", operator(columnValue)) // Use gt, gte, lt, lte, startsWith,...
     * ```
     *
     * @param column The name of the column to filter.
     * @param value The value to filter.
     * @returns A new Query object.
     */
    filter<F extends SelectableColumn<Record>>(column: F, value: Filter<NonNullable<ValueAtColumn<Record, F>>>): Query<Record, Result>;
    /**
     * Builds a new query object adding one or more constraints. Examples:
     *
     * ```
     * query.filter({ "columnName": columnValue })
     * query.filter({
     *   "columnName": operator(columnValue) // Use gt, gte, lt, lte, startsWith,...
     * })
     * ```
     *
     * @param filters A filter object
     * @returns A new Query object.
     */
    filter(filters?: Filter<Record>): Query<Record, Result>;
    /**
     * Builds a new query with a new sort option.
     * @param column The column name.
     * @param direction The direction. Either ascending or descending.
     * @returns A new Query object.
     */
    sort<F extends ColumnsByValue<Record, any>>(column: F, direction?: SortDirection): Query<Record, Result>;
    /**
     * Builds a new query specifying the set of columns to be returned in the query response.
     * @param columns Array of column names to be returned by the query.
     * @returns A new Query object.
     */
    select<K extends SelectableColumn<Record>>(columns: K[]): Query<Record, SelectedPick<Record, K[]>>;
    /**
     * Get paginated results
     *
     * @returns A page of results
     */
    getPaginated(): Promise<Page<Record, Result>>;
    /**
     * Get paginated results
     *
     * @param options Pagination options
     * @returns A page of results
     */
    getPaginated(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<Page<Record, Result>>;
    /**
     * Get paginated results
     *
     * @param options Pagination options
     * @returns A page of results
     */
    getPaginated<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(options: Options): Promise<Page<Record, SelectedPick<Record, typeof options['columns']>>>;
    /**
     * Get results in an iterator
     *
     * @async
     * @returns Async interable of results
     */
    [Symbol.asyncIterator](): AsyncIterableIterator<Result>;
    /**
     * Build an iterator of results
     *
     * @returns Async generator of results array
     */
    getIterator(): AsyncGenerator<Result[]>;
    /**
     * Build an iterator of results
     *
     * @param options Pagination options with batchSize
     * @returns Async generator of results array
     */
    getIterator(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & {
        batchSize?: number;
    }): AsyncGenerator<Result[]>;
    /**
     * Build an iterator of results
     *
     * @param options Pagination options with batchSize
     * @returns Async generator of results array
     */
    getIterator<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & {
        batchSize?: number;
    }>(options: Options): AsyncGenerator<SelectedPick<Record, typeof options['columns']>[]>;
    /**
     * Performs the query in the database and returns a set of results.
     * @returns An array of records from the database.
     */
    getMany(): Promise<RecordArray<Result>>;
    /**
     * Performs the query in the database and returns a set of results.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getMany<Options extends RequiredBy<QueryOptions<Record>, 'columns'>>(options: Options): Promise<RecordArray<SelectedPick<Record, typeof options['columns']>>>;
    /**
     * Performs the query in the database and returns a set of results.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getMany(options: OmitBy<QueryOptions<Record>, 'columns'>): Promise<RecordArray<Result>>;
    /**
     * Performs the query in the database and returns all the results.
     * Warning: If there are a large number of results, this method can have performance implications.
     * @returns An array of records from the database.
     */
    getAll(): Promise<Result[]>;
    /**
     * Performs the query in the database and returns all the results.
     * Warning: If there are a large number of results, this method can have performance implications.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getAll<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'> & {
        batchSize?: number;
    }>(options: Options): Promise<SelectedPick<Record, typeof options['columns']>[]>;
    /**
     * Performs the query in the database and returns all the results.
     * Warning: If there are a large number of results, this method can have performance implications.
     * @param options Additional options to be used when performing the query.
     * @returns An array of records from the database.
     */
    getAll(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'> & {
        batchSize?: number;
    }): Promise<Result[]>;
    /**
     * Performs the query in the database and returns the first result.
     * @returns The first record that matches the query, or null if no record matched the query.
     */
    getFirst(): Promise<Result | null>;
    /**
     * Performs the query in the database and returns the first result.
     * @param options Additional options to be used when performing the query.
     * @returns The first record that matches the query, or null if no record matched the query.
     */
    getFirst<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(options: Options): Promise<SelectedPick<Record, typeof options['columns']> | null>;
    /**
     * Performs the query in the database and returns the first result.
     * @param options Additional options to be used when performing the query.
     * @returns The first record that matches the query, or null if no record matched the query.
     */
    getFirst(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result | null>;
    /**
     * Performs the query in the database and returns the first result.
     * @returns The first record that matches the query, or null if no record matched the query.
     * @throws if there are no results.
     */
    getFirstOrThrow(): Promise<Result>;
    /**
     * Performs the query in the database and returns the first result.
     * @param options Additional options to be used when performing the query.
     * @returns The first record that matches the query, or null if no record matched the query.
     * @throws if there are no results.
     */
    getFirstOrThrow<Options extends RequiredBy<OmitBy<QueryOptions<Record>, 'pagination'>, 'columns'>>(options: Options): Promise<SelectedPick<Record, typeof options['columns']>>;
    /**
     * Performs the query in the database and returns the first result.
     * @param options Additional options to be used when performing the query.
     * @returns The first record that matches the query, or null if no record matched the query.
     * @throws if there are no results.
     */
    getFirstOrThrow(options: OmitBy<QueryOptions<Record>, 'columns' | 'pagination'>): Promise<Result>;
    summarize<Expression extends Dictionary<SummarizeExpression<Record>>, Columns extends SelectableColumn<Record>[]>(params?: SummarizeParams<Record, Expression, Columns>): Promise<SummarizeResult<Record, Expression, Columns>>;
    /**
     * Builds a new query object adding a cache TTL in milliseconds.
     * @param ttl The cache TTL in milliseconds.
     * @returns A new Query object.
     */
    cache(ttl: number): Query<Record, Result>;
    /**
     * Retrieve next page of records
     *
     * @returns A new page object.
     */
    nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieve previous page of records
     *
     * @returns A new page object
     */
    previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieve start page of records
     *
     * @returns A new page object
     */
    startPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieve last page of records
     *
     * @returns A new page object
     */
    endPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * @returns Boolean indicating if there is a next page
     */
    hasNextPage(): boolean;
}

declare type PaginationQueryMeta = {
    page: {
        cursor: string;
        more: boolean;
    };
};
interface Paginable<Record extends XataRecord, Result extends XataRecord = Record> {
    meta: PaginationQueryMeta;
    records: RecordArray<Result>;
    nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    startPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    endPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    hasNextPage(): boolean;
}
/**
 * A Page contains a set of results from a query plus metadata about the retrieved
 * set of values such as the cursor, required to retrieve additional records.
 */
declare class Page<Record extends XataRecord, Result extends XataRecord = Record> implements Paginable<Record, Result> {
    #private;
    /**
     * Page metadata, required to retrieve additional records.
     */
    readonly meta: PaginationQueryMeta;
    /**
     * The set of results for this page.
     */
    readonly records: RecordArray<Result>;
    constructor(query: Query<Record, Result>, meta: PaginationQueryMeta, records?: Result[]);
    /**
     * Retrieves the next page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The next page or results.
     */
    nextPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieves the previous page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The previous page or results.
     */
    previousPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieves the start page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The start page or results.
     */
    startPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Retrieves the end page of results.
     * @param size Maximum number of results to be retrieved.
     * @param offset Number of results to skip when retrieving the results.
     * @returns The end page or results.
     */
    endPage(size?: number, offset?: number): Promise<Page<Record, Result>>;
    /**
     * Shortcut method to check if there will be additional results if the next page of results is retrieved.
     * @returns Whether or not there will be additional results in the next page of results.
     */
    hasNextPage(): boolean;
}
declare type CursorNavigationOptions = {
    start?: string;
} | {
    end?: string;
} | {
    after?: string;
    before?: string;
};
declare type OffsetNavigationOptions = {
    size?: number;
    offset?: number;
};
declare const PAGINATION_MAX_SIZE = 200;
declare const PAGINATION_DEFAULT_SIZE = 20;
declare const PAGINATION_MAX_OFFSET = 800;
declare const PAGINATION_DEFAULT_OFFSET = 0;
declare function isCursorPaginationOptions(options: Record<string, unknown> | undefined | null): options is CursorNavigationOptions;
declare class RecordArray<Result extends XataRecord> extends Array<Result> {
    #private;
    constructor(page: Paginable<any, Result>, overrideRecords?: Result[]);
    static parseConstructorParams(...args: any[]): any[];
    toArray(): Result[];
    map<U>(callbackfn: (value: Result, index: number, array: Result[]) => U, thisArg?: any): U[];
    /**
     * Retrieve next page of records
     *
     * @returns A new array of objects
     */
    nextPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * Retrieve previous page of records
     *
     * @returns A new array of objects
     */
    previousPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * Retrieve start page of records
     *
     * @returns A new array of objects
     */
    startPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * Retrieve end page of records
     *
     * @returns A new array of objects
     */
    endPage(size?: number, offset?: number): Promise<RecordArray<Result>>;
    /**
     * @returns Boolean indicating if there is a next page
     */
    hasNextPage(): boolean;
}

/**
 * Common interface for performing operations on a table.
 */
declare abstract class Repository<Record extends XataRecord> extends Query<Record, Readonly<SelectedPick<Record, ['*']>>> {
    abstract create<K extends SelectableColumn<Record>>(object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    abstract create(object: Omit<EditableData<Record>, 'id'> & Partial<Identifiable>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates a single record in the table with a unique id.
     * @param id The unique id.
     * @param object Object containing the column names with their values to be stored in the table.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     */
    abstract create<K extends SelectableColumn<Record>>(id: string, object: Omit<EditableData<Record>, 'id'>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Creates a single record in the table with a unique id.
     * @param id The unique id.
     * @param object Object containing the column names with their values to be stored in the table.
     * @returns The full persisted record.
     */
    abstract create(id: string, object: Omit<EditableData<Record>, 'id'>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates multiple records in the table.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the persisted records in order.
     */
    abstract create<K extends SelectableColumn<Record>>(objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    /**
     * Creates multiple records in the table.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @returns Array of the persisted records in order.
     */
    abstract create(objects: Array<Omit<EditableData<Record>, 'id'> & Partial<Identifiable>>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Queries a single record from the table given its unique id.
     * @param id The unique id.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted record for the given id or null if the record could not be found.
     */
    abstract read<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;
    /**
     * Queries a single record from the table given its unique id.
     * @param id The unique id.
     * @returns The persisted record for the given id or null if the record could not be found.
     */
    abstract read(id: string): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;
    /**
     * Queries multiple records from the table given their unique id.
     * @param ids The unique ids array.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted records for the given ids in order (if a record could not be found null is returned).
     */
    abstract read<K extends SelectableColumn<Record>>(ids: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    /**
     * Queries multiple records from the table given their unique id.
     * @param ids The unique ids array.
     * @returns The persisted records for the given ids in order (if a record could not be found null is returned).
     */
    abstract read(ids: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    /**
     * Queries a single record from the table by the id in the object.
     * @param object Object containing the id of the record.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted record for the given id or null if the record could not be found.
     */
    abstract read<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;
    /**
     * Queries a single record from the table by the id in the object.
     * @param object Object containing the id of the record.
     * @returns The persisted record for the given id or null if the record could not be found.
     */
    abstract read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;
    /**
     * Queries multiple records from the table by the ids in the objects.
     * @param objects Array of objects containing the ids of the records.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted records for the given ids in order (if a record could not be found null is returned).
     */
    abstract read<K extends SelectableColumn<Record>>(objects: Identifiable[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    /**
     * Queries multiple records from the table by the ids in the objects.
     * @param objects Array of objects containing the ids of the records.
     * @returns The persisted records for the given ids in order (if a record could not be found null is returned).
     */
    abstract read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    /**
     * Queries a single record from the table given its unique id.
     * @param id The unique id.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted record for the given id.
     * @throws If the record could not be found.
     */
    abstract readOrThrow<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Queries a single record from the table given its unique id.
     * @param id The unique id.
     * @returns The persisted record for the given id.
     * @throws If the record could not be found.
     */
    abstract readOrThrow(id: string): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Queries multiple records from the table given their unique id.
     * @param ids The unique ids array.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted records for the given ids in order.
     * @throws If one or more records could not be found.
     */
    abstract readOrThrow<K extends SelectableColumn<Record>>(ids: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    /**
     * Queries multiple records from the table given their unique id.
     * @param ids The unique ids array.
     * @returns The persisted records for the given ids in order.
     * @throws If one or more records could not be found.
     */
    abstract readOrThrow(ids: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    /**
     * Queries a single record from the table by the id in the object.
     * @param object Object containing the id of the record.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted record for the given id.
     * @throws If the record could not be found.
     */
    abstract readOrThrow<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Queries a single record from the table by the id in the object.
     * @param object Object containing the id of the record.
     * @returns The persisted record for the given id.
     * @throws If the record could not be found.
     */
    abstract readOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Queries multiple records from the table by the ids in the objects.
     * @param objects Array of objects containing the ids of the records.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The persisted records for the given ids in order.
     * @throws If one or more records could not be found.
     */
    abstract readOrThrow<K extends SelectableColumn<Record>>(objects: Identifiable[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    /**
     * Queries multiple records from the table by the ids in the objects.
     * @param objects Array of objects containing the ids of the records.
     * @returns The persisted records for the given ids in order.
     * @throws If one or more records could not be found.
     */
    abstract readOrThrow(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    /**
     * Partially update a single record.
     * @param object An object with its id and the columns to be updated.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record, null if the record could not be found.
     */
    abstract update<K extends SelectableColumn<Record>>(object: Partial<EditableData<Record>> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    /**
     * Partially update a single record.
     * @param object An object with its id and the columns to be updated.
     * @returns The full persisted record, null if the record could not be found.
     */
    abstract update(object: Partial<EditableData<Record>> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    /**
     * Partially update a single record given its unique id.
     * @param id The unique id.
     * @param object The column names and their values that have to be updated.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record, null if the record could not be found.
     */
    abstract update<K extends SelectableColumn<Record>>(id: string, object: Partial<EditableData<Record>>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    /**
     * Partially update a single record given its unique id.
     * @param id The unique id.
     * @param object The column names and their values that have to be updated.
     * @returns The full persisted record, null if the record could not be found.
     */
    abstract update(id: string, object: Partial<EditableData<Record>>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    /**
     * Partially updates multiple records.
     * @param objects An array of objects with their ids and columns to be updated.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the persisted records in order (if a record could not be found null is returned).
     */
    abstract update<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    /**
     * Partially updates multiple records.
     * @param objects An array of objects with their ids and columns to be updated.
     * @returns Array of the persisted records in order (if a record could not be found null is returned).
     */
    abstract update(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    /**
     * Partially update a single record.
     * @param object An object with its id and the columns to be updated.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     * @throws If the record could not be found.
     */
    abstract updateOrThrow<K extends SelectableColumn<Record>>(object: Partial<EditableData<Record>> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Partially update a single record.
     * @param object An object with its id and the columns to be updated.
     * @returns The full persisted record.
     * @throws If the record could not be found.
     */
    abstract updateOrThrow(object: Partial<EditableData<Record>> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Partially update a single record given its unique id.
     * @param id The unique id.
     * @param object The column names and their values that have to be updated.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     * @throws If the record could not be found.
     */
    abstract updateOrThrow<K extends SelectableColumn<Record>>(id: string, object: Partial<EditableData<Record>>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Partially update a single record given its unique id.
     * @param id The unique id.
     * @param object The column names and their values that have to be updated.
     * @returns The full persisted record.
     * @throws If the record could not be found.
     */
    abstract updateOrThrow(id: string, object: Partial<EditableData<Record>>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Partially updates multiple records.
     * @param objects An array of objects with their ids and columns to be updated.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the persisted records in order.
     * @throws If one or more records could not be found.
     */
    abstract updateOrThrow<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    /**
     * Partially updates multiple records.
     * @param objects An array of objects with their ids and columns to be updated.
     * @returns Array of the persisted records in order.
     * @throws If one or more records could not be found.
     */
    abstract updateOrThrow(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be partially updated, otherwise a new record will be created.
     * @param object Object containing the column names with their values to be persisted in the table.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     */
    abstract createOrUpdate<K extends SelectableColumn<Record>>(object: EditableData<Record> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be partially updated, otherwise a new record will be created.
     * @param object Object containing the column names with their values to be persisted in the table.
     * @returns The full persisted record.
     */
    abstract createOrUpdate(object: EditableData<Record> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be partially updated, otherwise a new record will be created.
     * @param id A unique id.
     * @param object The column names and the values to be persisted.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     */
    abstract createOrUpdate<K extends SelectableColumn<Record>>(id: string, object: Omit<EditableData<Record>, 'id'>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be partially updated, otherwise a new record will be created.
     * @param id A unique id.
     * @param object The column names and the values to be persisted.
     * @returns The full persisted record.
     */
    abstract createOrUpdate(id: string, object: Omit<EditableData<Record>, 'id'>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be partially updated, otherwise a new record will be created.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the persisted records.
     */
    abstract createOrUpdate<K extends SelectableColumn<Record>>(objects: Array<EditableData<Record> & Identifiable>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    /**
     * Creates or updates a single record. If a record exists with the given id,
     * it will be partially updated, otherwise a new record will be created.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @returns Array of the persisted records.
     */
    abstract createOrUpdate(objects: Array<EditableData<Record> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Creates or replaces a single record. If a record exists with the given id,
     * it will be replaced, otherwise a new record will be created.
     * @param object Object containing the column names with their values to be persisted in the table.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     */
    abstract createOrReplace<K extends SelectableColumn<Record>>(object: EditableData<Record> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Creates or replaces a single record. If a record exists with the given id,
     * it will be replaced, otherwise a new record will be created.
     * @param object Object containing the column names with their values to be persisted in the table.
     * @returns The full persisted record.
     */
    abstract createOrReplace(object: EditableData<Record> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates or replaces a single record. If a record exists with the given id,
     * it will be replaced, otherwise a new record will be created.
     * @param id A unique id.
     * @param object The column names and the values to be persisted.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The full persisted record.
     */
    abstract createOrReplace<K extends SelectableColumn<Record>>(id: string, object: Omit<EditableData<Record>, 'id'>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Creates or replaces a single record. If a record exists with the given id,
     * it will be replaced, otherwise a new record will be created.
     * @param id A unique id.
     * @param object The column names and the values to be persisted.
     * @returns The full persisted record.
     */
    abstract createOrReplace(id: string, object: Omit<EditableData<Record>, 'id'>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Creates or replaces a single record. If a record exists with the given id,
     * it will be replaced, otherwise a new record will be created.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the persisted records.
     */
    abstract createOrReplace<K extends SelectableColumn<Record>>(objects: Array<EditableData<Record> & Identifiable>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    /**
     * Creates or replaces a single record. If a record exists with the given id,
     * it will be replaced, otherwise a new record will be created.
     * @param objects Array of objects with the column names and the values to be stored in the table.
     * @returns Array of the persisted records.
     */
    abstract createOrReplace(objects: Array<EditableData<Record> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    /**
     * Deletes a record given its unique id.
     * @param object An object with a unique id.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The deleted record, null if the record could not be found.
     */
    abstract delete<K extends SelectableColumn<Record>>(object: Identifiable & Partial<EditableData<Record>>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    /**
     * Deletes a record given its unique id.
     * @param object An object with a unique id.
     * @returns The deleted record, null if the record could not be found.
     */
    abstract delete(object: Identifiable & Partial<EditableData<Record>>): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    /**
     * Deletes a record given a unique id.
     * @param id The unique id.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The deleted record, null if the record could not be found.
     */
    abstract delete<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    /**
     * Deletes a record given a unique id.
     * @param id The unique id.
     * @returns The deleted record, null if the record could not be found.
     */
    abstract delete(id: string): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    /**
     * Deletes multiple records given an array of objects with ids.
     * @param objects An array of objects with unique ids.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     */
    abstract delete<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    /**
     * Deletes multiple records given an array of objects with ids.
     * @param objects An array of objects with unique ids.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     */
    abstract delete(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    /**
     * Deletes multiple records given an array of unique ids.
     * @param objects An array of ids.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     */
    abstract delete<K extends SelectableColumn<Record>>(objects: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    /**
     * Deletes multiple records given an array of unique ids.
     * @param objects An array of ids.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     */
    abstract delete(objects: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    /**
     * Deletes a record given its unique id.
     * @param object An object with a unique id.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The deleted record, null if the record could not be found.
     * @throws If the record could not be found.
     */
    abstract deleteOrThrow<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Deletes a record given its unique id.
     * @param object An object with a unique id.
     * @returns The deleted record, null if the record could not be found.
     * @throws If the record could not be found.
     */
    abstract deleteOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Deletes a record given a unique id.
     * @param id The unique id.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns The deleted record, null if the record could not be found.
     * @throws If the record could not be found.
     */
    abstract deleteOrThrow<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    /**
     * Deletes a record given a unique id.
     * @param id The unique id.
     * @returns The deleted record, null if the record could not be found.
     * @throws If the record could not be found.
     */
    abstract deleteOrThrow(id: string): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    /**
     * Deletes multiple records given an array of objects with ids.
     * @param objects An array of objects with unique ids.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     * @throws If one or more records could not be found.
     */
    abstract deleteOrThrow<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    /**
     * Deletes multiple records given an array of objects with ids.
     * @param objects An array of objects with unique ids.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     * @throws If one or more records could not be found.
     */
    abstract deleteOrThrow(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    /**
     * Deletes multiple records given an array of unique ids.
     * @param objects An array of ids.
     * @param columns Array of columns to be returned. If not specified, first level columns will be returned.
     * @returns Array of the deleted records in order (if a record could not be found null is returned).
     * @throws If one or more records could not be found.
     */
    abstract deleteOrThrow<K extends SelectableColumn<Record>>(objects: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    /**
     * Deletes multiple records given an array of unique ids.
     * @param objects An array of ids.
     * @returns Array of the deleted records in order.
     * @throws If one or more records could not be found.
     */
    abstract deleteOrThrow(objects: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    /**
     * Search for records in the table.
     * @param query The query to search for.
     * @param options The options to search with (like: fuzziness)
     * @returns The found records.
     */
    abstract search(query: string, options?: {
        fuzziness?: FuzzinessExpression;
        prefix?: PrefixExpression;
        highlight?: HighlightExpression;
        filter?: Filter<Record>;
        boosters?: Boosters<Record>[];
    }): Promise<SearchXataRecord<SelectedPick<Record, ['*']>>[]>;
    /**
     * Aggregates records in the table.
     * @param expression The aggregations to perform.
     * @param filter The filter to apply to the queried records.
     * @returns The requested aggregations.
     */
    abstract aggregate<Expression extends Dictionary<AggregationExpression<Record>>>(expression?: Expression, filter?: Filter<Record>): Promise<AggregationResult<Record, Expression>>;
    abstract query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>>;
}
declare class RestRepository<Record extends XataRecord> extends Query<Record, SelectedPick<Record, ['*']>> implements Repository<Record> {
    #private;
    constructor(options: {
        table: string;
        db: SchemaPluginResult<any>;
        pluginOptions: XataPluginOptions;
        schemaTables?: Table[];
    });
    create<K extends SelectableColumn<Record>>(object: EditableData<Record> & Partial<Identifiable>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    create(object: EditableData<Record> & Partial<Identifiable>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    create<K extends SelectableColumn<Record>>(id: string, object: EditableData<Record>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    create(id: string, object: EditableData<Record>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    create<K extends SelectableColumn<Record>>(objects: Array<EditableData<Record> & Partial<Identifiable>>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    create(objects: Array<EditableData<Record> & Partial<Identifiable>>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    read<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;
    read(id: string): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;
    read<K extends SelectableColumn<Record>>(ids: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    read(ids: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    read<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns> | null>>;
    read(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']> | null>>;
    read<K extends SelectableColumn<Record>>(objects: Identifiable[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    read(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    readOrThrow<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    readOrThrow(id: string): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    readOrThrow<K extends SelectableColumn<Record>>(ids: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    readOrThrow(ids: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    readOrThrow<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    readOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    readOrThrow<K extends SelectableColumn<Record>>(objects: Identifiable[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    readOrThrow(objects: Identifiable[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    update<K extends SelectableColumn<Record>>(object: Partial<EditableData<Record>> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    update(object: Partial<EditableData<Record>> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    update<K extends SelectableColumn<Record>>(id: string, object: Partial<EditableData<Record>>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    update(id: string, object: Partial<EditableData<Record>>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    update<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    update(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    updateOrThrow<K extends SelectableColumn<Record>>(object: Partial<EditableData<Record>> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    updateOrThrow(object: Partial<EditableData<Record>> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    updateOrThrow<K extends SelectableColumn<Record>>(id: string, object: Partial<EditableData<Record>>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    updateOrThrow(id: string, object: Partial<EditableData<Record>>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    updateOrThrow<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    updateOrThrow(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    createOrUpdate<K extends SelectableColumn<Record>>(object: EditableData<Record> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    createOrUpdate(object: EditableData<Record> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    createOrUpdate<K extends SelectableColumn<Record>>(id: string, object: Omit<EditableData<Record>, 'id'>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    createOrUpdate(id: string, object: Omit<EditableData<Record>, 'id'>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    createOrUpdate<K extends SelectableColumn<Record>>(objects: Array<EditableData<Record> & Identifiable>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    createOrUpdate(objects: Array<EditableData<Record> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    createOrReplace<K extends SelectableColumn<Record>>(object: EditableData<Record> & Identifiable, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    createOrReplace(object: EditableData<Record> & Identifiable, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    createOrReplace<K extends SelectableColumn<Record>>(id: string, object: Omit<EditableData<Record>, 'id'>, columns: K[], options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    createOrReplace(id: string, object: Omit<EditableData<Record>, 'id'>, options?: {
        ifVersion?: number;
    }): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    createOrReplace<K extends SelectableColumn<Record>>(objects: Array<EditableData<Record> & Identifiable>, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>[]>;
    createOrReplace(objects: Array<EditableData<Record> & Identifiable>): Promise<Readonly<SelectedPick<Record, ['*']>>[]>;
    delete<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    delete(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    delete<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>> | null>;
    delete(id: string): Promise<Readonly<SelectedPick<Record, ['*']>> | null>;
    delete<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    delete(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    delete<K extends SelectableColumn<Record>>(objects: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>> | null>>;
    delete(objects: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>> | null>>;
    deleteOrThrow<K extends SelectableColumn<Record>>(object: Identifiable, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    deleteOrThrow(object: Identifiable): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    deleteOrThrow<K extends SelectableColumn<Record>>(id: string, columns: K[]): Promise<Readonly<SelectedPick<Record, typeof columns>>>;
    deleteOrThrow(id: string): Promise<Readonly<SelectedPick<Record, ['*']>>>;
    deleteOrThrow<K extends SelectableColumn<Record>>(objects: Array<Partial<EditableData<Record>> & Identifiable>, columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    deleteOrThrow(objects: Array<Partial<EditableData<Record>> & Identifiable>): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    deleteOrThrow<K extends SelectableColumn<Record>>(objects: string[], columns: K[]): Promise<Array<Readonly<SelectedPick<Record, typeof columns>>>>;
    deleteOrThrow(objects: string[]): Promise<Array<Readonly<SelectedPick<Record, ['*']>>>>;
    search(query: string, options?: {
        fuzziness?: FuzzinessExpression;
        prefix?: PrefixExpression;
        highlight?: HighlightExpression;
        filter?: Filter<Record>;
        boosters?: Boosters<Record>[];
    }): Promise<any>;
    aggregate<Expression extends Dictionary<AggregationExpression<Record>>>(aggs?: Expression, filter?: Filter<Record>): Promise<any>;
    query<Result extends XataRecord>(query: Query<Record, Result>): Promise<Page<Record, Result>>;
    summarizeTable<Result extends XataRecord>(query: Query<Record, Result>, summaries?: Dictionary<SummarizeExpression<Record>>, summariesFilter?: FilterExpression): Promise<SummarizeResponse>;
}

declare type BaseSchema = {
    name: string;
    columns: readonly ({
        name: string;
        type: Column['type'];
        notNull?: boolean;
    } | {
        name: string;
        type: 'link';
        link: {
            table: string;
        };
    } | {
        name: string;
        type: 'object';
        columns: {
            name: string;
            type: string;
        }[];
    })[];
};
declare type SchemaInference<T extends readonly BaseSchema[]> = T extends never[] ? Record<string, Record<string, any>> : T extends readonly unknown[] ? T[number] extends {
    name: string;
    columns: readonly unknown[];
} ? {
    [K in T[number]['name']]: TableType<T[number], K>;
} : never : never;
declare type TableType<Tables, TableName> = Tables & {
    name: TableName;
} extends infer Table ? Table extends {
    name: string;
    columns: infer Columns;
} ? Columns extends readonly unknown[] ? Columns[number] extends {
    name: string;
    type: string;
} ? Identifiable & UnionToIntersection<Values<{
    [K in Columns[number]['name']]: PropertyType<Tables, Columns[number], K>;
}>> : never : never : never : never;
declare type PropertyType<Tables, Properties, PropertyName extends PropertyKey> = Properties & {
    name: PropertyName;
} extends infer Property ? Property extends {
    name: string;
    type: infer Type;
    link?: {
        table: infer LinkedTable;
    };
    columns?: infer ObjectColumns;
    notNull?: infer NotNull;
} ? NotNull extends true ? {
    [K in PropertyName]: InnerType<Type, ObjectColumns, Tables, LinkedTable>;
} : {
    [K in PropertyName]?: InnerType<Type, ObjectColumns, Tables, LinkedTable> | null;
} : never : never;
declare type InnerType<Type, ObjectColumns, Tables, LinkedTable> = Type extends 'string' | 'text' | 'email' ? string : Type extends 'int' | 'float' ? number : Type extends 'bool' ? boolean : Type extends 'datetime' ? Date : Type extends 'multiple' ? string[] : Type extends 'object' ? ObjectColumns extends readonly unknown[] ? ObjectColumns[number] extends {
    name: string;
    type: string;
} ? UnionToIntersection<Values<{
    [K in ObjectColumns[number]['name']]: PropertyType<Tables, ObjectColumns[number], K>;
}>> : never : never : Type extends 'link' ? TableType<Tables, LinkedTable> & XataRecord : never;

/**
 * Operator to restrict results to only values that are greater than the given value.
 */
declare const greaterThan: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than the given value.
 */
declare const gt: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than or equal to the given value.
 */
declare const greaterThanEquals: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than or equal to the given value.
 */
declare const greaterEquals: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than or equal to the given value.
 */
declare const gte: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are greater than or equal to the given value.
 */
declare const ge: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than the given value.
 */
declare const lessThan: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than the given value.
 */
declare const lt: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than or equal to the given value.
 */
declare const lessThanEquals: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than or equal to the given value.
 */
declare const lessEquals: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than or equal to the given value.
 */
declare const lte: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are lower than or equal to the given value.
 */
declare const le: <T extends ComparableType>(value: T) => ComparableTypeFilter<T>;
/**
 * Operator to restrict results to only values that are not null.
 */
declare const exists: <T>(column?: ColumnsByValue<T, any> | undefined) => ExistanceFilter<T>;
/**
 * Operator to restrict results to only values that are null.
 */
declare const notExists: <T>(column?: ColumnsByValue<T, any> | undefined) => ExistanceFilter<T>;
/**
 * Operator to restrict results to only values that start with the given prefix.
 */
declare const startsWith: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results to only values that end with the given suffix.
 */
declare const endsWith: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results to only values that match the given pattern.
 */
declare const pattern: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results to only values that are equal to the given value.
 */
declare const is: <T>(value: T) => PropertyFilter<T>;
/**
 * Operator to restrict results to only values that are equal to the given value.
 */
declare const equals: <T>(value: T) => PropertyFilter<T>;
/**
 * Operator to restrict results to only values that are not equal to the given value.
 */
declare const isNot: <T>(value: T) => PropertyFilter<T>;
/**
 * Operator to restrict results to only values that contain the given value.
 */
declare const contains: (value: string) => StringTypeFilter;
/**
 * Operator to restrict results if some array items match the predicate.
 */
declare const includes: <T>(value: T) => ArrayFilter<T>;
/**
 * Operator to restrict results if all array items match the predicate.
 */
declare const includesAll: <T>(value: T) => ArrayFilter<T>;
/**
 * Operator to restrict results if none array items match the predicate.
 */
declare const includesNone: <T>(value: T) => ArrayFilter<T>;
/**
 * Operator to restrict results if some array items match the predicate.
 */
declare const includesAny: <T>(value: T) => ArrayFilter<T>;

declare type SchemaDefinition = {
    table: string;
};
declare type SchemaPluginResult<Schemas extends Record<string, XataRecord>> = {
    [Key in keyof Schemas]: Repository<Schemas[Key]>;
};
declare class SchemaPlugin<Schemas extends Record<string, XataRecord>> extends XataPlugin {
    #private;
    constructor(schemaTables?: Schemas.Table[]);
    build(pluginOptions: XataPluginOptions): SchemaPluginResult<Schemas>;
}

declare type BranchStrategyValue = string | undefined | null;
declare type BranchStrategyBuilder = () => BranchStrategyValue | Promise<BranchStrategyValue>;
declare type BranchStrategy = BranchStrategyValue | BranchStrategyBuilder;
declare type BranchStrategyOption = NonNullable<BranchStrategy | BranchStrategy[]>;

declare type BaseClientOptions = {
    fetch?: FetchImpl;
    apiKey?: string;
    databaseURL?: string;
    branch?: BranchStrategyOption;
    cache?: CacheImpl;
    trace?: TraceFunction;
    enableBrowser?: boolean;
};
declare const buildClient: <Plugins extends Record<string, XataPlugin> = {}>(plugins?: Plugins | undefined) => ClientConstructor<Plugins>;
interface ClientConstructor<Plugins extends Record<string, XataPlugin>> {
    new <Schemas extends Record<string, XataRecord> = {}>(options?: Partial<BaseClientOptions>, schemaTables?: readonly BaseSchema[]): Omit<{
        db: Awaited<ReturnType<SchemaPlugin<Schemas>['build']>>;
        search: Awaited<ReturnType<SearchPlugin<Schemas>['build']>>;
    }, keyof Plugins> & {
        [Key in StringKeys<NonNullable<Plugins>>]: Awaited<ReturnType<NonNullable<Plugins>[Key]['build']>>;
    } & {
        getConfig(): Promise<{
            databaseURL: string;
            branch: string;
        }>;
    };
}
declare const BaseClient_base: ClientConstructor<{}>;
declare class BaseClient extends BaseClient_base<Record<string, any>> {
}

declare class Serializer {
    classes: Record<string, any>;
    add(clazz: any): void;
    toJSON<T>(data: T): string;
    fromJSON<T>(json: string): T;
}
declare const serialize: <T>(data: T) => string;
declare const deserialize: <T>(json: string) => T;

declare type BranchResolutionOptions = {
    databaseURL?: string;
    apiKey?: string;
    fetchImpl?: FetchImpl;
};
declare function getCurrentBranchName(options?: BranchResolutionOptions): Promise<string>;
declare function getCurrentBranchDetails(options?: BranchResolutionOptions): Promise<DBBranch | null>;
declare function getDatabaseURL(): string | undefined;

declare function getAPIKey(): string | undefined;

interface Body {
    arrayBuffer(): Promise<ArrayBuffer>;
    blob(): Promise<Blob>;
    formData(): Promise<FormData>;
    json(): Promise<any>;
    text(): Promise<string>;
}
interface Blob {
    readonly size: number;
    readonly type: string;
    arrayBuffer(): Promise<ArrayBuffer>;
    slice(start?: number, end?: number, contentType?: string): Blob;
    text(): Promise<string>;
}
/** Provides information about files and allows JavaScript in a web page to access their content. */
interface File extends Blob {
    readonly lastModified: number;
    readonly name: string;
    readonly webkitRelativePath: string;
}
declare type FormDataEntryValue = File | string;
/** Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data". */
interface FormData {
    append(name: string, value: string | Blob, fileName?: string): void;
    delete(name: string): void;
    get(name: string): FormDataEntryValue | null;
    getAll(name: string): FormDataEntryValue[];
    has(name: string): boolean;
    set(name: string, value: string | Blob, fileName?: string): void;
    forEach(callbackfn: (value: FormDataEntryValue, key: string, parent: FormData) => void, thisArg?: any): void;
}
/** This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence. */
interface Headers {
    append(name: string, value: string): void;
    delete(name: string): void;
    get(name: string): string | null;
    has(name: string): boolean;
    set(name: string, value: string): void;
    forEach(callbackfn: (value: string, key: string, parent: Headers) => void, thisArg?: any): void;
}
interface Request extends Body {
    /** Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser's cache when fetching. */
    readonly cache: 'default' | 'force-cache' | 'no-cache' | 'no-store' | 'only-if-cached' | 'reload';
    /** Returns the credentials mode associated with request, which is a string indicating whether credentials will be sent with the request always, never, or only when sent to a same-origin URL. */
    readonly credentials: 'include' | 'omit' | 'same-origin';
    /** Returns the kind of resource requested by request, e.g., "document" or "script". */
    readonly destination: '' | 'audio' | 'audioworklet' | 'document' | 'embed' | 'font' | 'frame' | 'iframe' | 'image' | 'manifest' | 'object' | 'paintworklet' | 'report' | 'script' | 'sharedworker' | 'style' | 'track' | 'video' | 'worker' | 'xslt';
    /** Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the "Host" header. */
    readonly headers: Headers;
    /** Returns request's subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI] */
    readonly integrity: string;
    /** Returns a boolean indicating whether or not request can outlive the global in which it was created. */
    readonly keepalive: boolean;
    /** Returns request's HTTP method, which is "GET" by default. */
    readonly method: string;
    /** Returns the mode associated with request, which is a string indicating whether the request will use CORS, or will be restricted to same-origin URLs. */
    readonly mode: 'cors' | 'navigate' | 'no-cors' | 'same-origin';
    /** Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default. */
    readonly redirect: 'error' | 'follow' | 'manual';
    /** Returns the referrer of request. Its value can be a same-origin URL if explicitly set in init, the empty string to indicate no referrer, and "about:client" when defaulting to the global's default. This is used during fetching to determine the value of the `Referer` header of the request being made. */
    readonly referrer: string;
    /** Returns the referrer policy associated with request. This is used during fetching to compute the value of the request's referrer. */
    readonly referrerPolicy: '' | 'no-referrer' | 'no-referrer-when-downgrade' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin' | 'unsafe-url';
    /** Returns the URL of request as a string. */
    readonly url: string;
    clone(): Request;
}

declare type XataWorkerContext<XataClient> = {
    xata: XataClient;
    request: Request;
    env: Record<string, string | undefined>;
};
declare type RemoveFirst<T> = T extends [any, ...infer U] ? U : never;
declare type WorkerRunnerConfig = {
    workspace: string;
    worker: string;
};
declare function buildWorkerRunner<XataClient>(config: WorkerRunnerConfig): <WorkerFunction extends (ctx: XataWorkerContext<XataClient>, ...args: any[]) => any>(name: string, _worker: WorkerFunction) => (...args: RemoveFirst<Parameters<WorkerFunction>>) => Promise<Awaited<ReturnType<WorkerFunction>>>;

declare class XataError extends Error {
    readonly status: number;
    constructor(message: string, status: number);
}

export { AcceptWorkspaceMemberInviteError, AcceptWorkspaceMemberInvitePathParams, AcceptWorkspaceMemberInviteVariables, AddGitBranchesEntryError, AddGitBranchesEntryPathParams, AddGitBranchesEntryRequestBody, AddGitBranchesEntryResponse, AddGitBranchesEntryVariables, AddTableColumnError, AddTableColumnPathParams, AddTableColumnVariables, AggregateTableError, AggregateTablePathParams, AggregateTableRequestBody, AggregateTableVariables, ApiExtraProps, ApplyBranchSchemaEditError, ApplyBranchSchemaEditPathParams, ApplyBranchSchemaEditRequestBody, ApplyBranchSchemaEditVariables, BaseClient, BaseClientOptions, BaseData, BaseSchema, BranchTransactionError, BranchTransactionPathParams, BranchTransactionRequestBody, BranchTransactionVariables, BulkInsertTableRecordsError, BulkInsertTableRecordsPathParams, BulkInsertTableRecordsQueryParams, BulkInsertTableRecordsRequestBody, BulkInsertTableRecordsVariables, CacheImpl, CancelWorkspaceMemberInviteError, CancelWorkspaceMemberInvitePathParams, CancelWorkspaceMemberInviteVariables, ClientConstructor, ColumnsByValue, CompareBranchSchemasError, CompareBranchSchemasPathParams, CompareBranchSchemasVariables, CompareBranchWithUserSchemaError, CompareBranchWithUserSchemaPathParams, CompareBranchWithUserSchemaRequestBody, CompareBranchWithUserSchemaVariables, CompareMigrationRequestError, CompareMigrationRequestPathParams, CompareMigrationRequestVariables, CreateBranchError, CreateBranchPathParams, CreateBranchQueryParams, CreateBranchRequestBody, CreateBranchResponse, CreateBranchVariables, CreateDatabaseError, CreateDatabasePathParams, CreateDatabaseRequestBody, CreateDatabaseResponse, CreateDatabaseVariables, CreateMigrationRequestError, CreateMigrationRequestPathParams, CreateMigrationRequestRequestBody, CreateMigrationRequestResponse, CreateMigrationRequestVariables, CreateTableError, CreateTablePathParams, CreateTableResponse, CreateTableVariables, CreateUserAPIKeyError, CreateUserAPIKeyPathParams, CreateUserAPIKeyResponse, CreateUserAPIKeyVariables, CreateWorkspaceError, CreateWorkspaceVariables, CursorNavigationOptions, DEPRECATEDcreateDatabaseError, DEPRECATEDcreateDatabasePathParams, DEPRECATEDcreateDatabaseRequestBody, DEPRECATEDcreateDatabaseResponse, DEPRECATEDcreateDatabaseVariables, DEPRECATEDdeleteDatabaseError, DEPRECATEDdeleteDatabasePathParams, DEPRECATEDdeleteDatabaseResponse, DEPRECATEDdeleteDatabaseVariables, DEPRECATEDgetDatabaseListError, DEPRECATEDgetDatabaseListPathParams, DEPRECATEDgetDatabaseListVariables, DEPRECATEDgetDatabaseMetadataError, DEPRECATEDgetDatabaseMetadataPathParams, DEPRECATEDgetDatabaseMetadataVariables, DEPRECATEDupdateDatabaseMetadataError, DEPRECATEDupdateDatabaseMetadataPathParams, DEPRECATEDupdateDatabaseMetadataRequestBody, DEPRECATEDupdateDatabaseMetadataVariables, DeleteBranchError, DeleteBranchPathParams, DeleteBranchResponse, DeleteBranchVariables, DeleteColumnError, DeleteColumnPathParams, DeleteColumnVariables, DeleteDatabaseError, DeleteDatabasePathParams, DeleteDatabaseResponse, DeleteDatabaseVariables, DeleteRecordError, DeleteRecordPathParams, DeleteRecordQueryParams, DeleteRecordVariables, DeleteTableError, DeleteTablePathParams, DeleteTableResponse, DeleteTableVariables, DeleteUserAPIKeyError, DeleteUserAPIKeyPathParams, DeleteUserAPIKeyVariables, DeleteUserError, DeleteUserVariables, DeleteWorkspaceError, DeleteWorkspacePathParams, DeleteWorkspaceVariables, EditableData, ExecuteBranchMigrationPlanError, ExecuteBranchMigrationPlanPathParams, ExecuteBranchMigrationPlanRequestBody, ExecuteBranchMigrationPlanVariables, FetchImpl, FetcherExtraProps, GetBranchDetailsError, GetBranchDetailsPathParams, GetBranchDetailsVariables, GetBranchListError, GetBranchListPathParams, GetBranchListVariables, GetBranchMetadataError, GetBranchMetadataPathParams, GetBranchMetadataVariables, GetBranchMigrationHistoryError, GetBranchMigrationHistoryPathParams, GetBranchMigrationHistoryRequestBody, GetBranchMigrationHistoryResponse, GetBranchMigrationHistoryVariables, GetBranchMigrationPlanError, GetBranchMigrationPlanPathParams, GetBranchMigrationPlanVariables, GetBranchSchemaHistoryError, GetBranchSchemaHistoryPathParams, GetBranchSchemaHistoryRequestBody, GetBranchSchemaHistoryResponse, GetBranchSchemaHistoryVariables, GetBranchStatsError, GetBranchStatsPathParams, GetBranchStatsResponse, GetBranchStatsVariables, GetColumnError, GetColumnPathParams, GetColumnVariables, GetDatabaseListError, GetDatabaseListPathParams, GetDatabaseListVariables, GetDatabaseMetadataError, GetDatabaseMetadataPathParams, GetDatabaseMetadataVariables, GetGitBranchesMappingError, GetGitBranchesMappingPathParams, GetGitBranchesMappingVariables, GetMigrationRequestError, GetMigrationRequestIsMergedError, GetMigrationRequestIsMergedPathParams, GetMigrationRequestIsMergedResponse, GetMigrationRequestIsMergedVariables, GetMigrationRequestPathParams, GetMigrationRequestVariables, GetRecordError, GetRecordPathParams, GetRecordQueryParams, GetRecordVariables, GetTableColumnsError, GetTableColumnsPathParams, GetTableColumnsResponse, GetTableColumnsVariables, GetTableSchemaError, GetTableSchemaPathParams, GetTableSchemaResponse, GetTableSchemaVariables, GetUserAPIKeysError, GetUserAPIKeysResponse, GetUserAPIKeysVariables, GetUserError, GetUserVariables, GetWorkspaceError, GetWorkspaceMembersListError, GetWorkspaceMembersListPathParams, GetWorkspaceMembersListVariables, GetWorkspacePathParams, GetWorkspaceVariables, GetWorkspacesListError, GetWorkspacesListResponse, GetWorkspacesListVariables, HostProvider, Identifiable, InsertRecordError, InsertRecordPathParams, InsertRecordQueryParams, InsertRecordVariables, InsertRecordWithIDError, InsertRecordWithIDPathParams, InsertRecordWithIDQueryParams, InsertRecordWithIDVariables, InviteWorkspaceMemberError, InviteWorkspaceMemberPathParams, InviteWorkspaceMemberRequestBody, InviteWorkspaceMemberVariables, Link, ListMigrationRequestsCommitsError, ListMigrationRequestsCommitsPathParams, ListMigrationRequestsCommitsRequestBody, ListMigrationRequestsCommitsResponse, ListMigrationRequestsCommitsVariables, ListRegionsError, ListRegionsPathParams, ListRegionsVariables, MergeMigrationRequestError, MergeMigrationRequestPathParams, MergeMigrationRequestVariables, OffsetNavigationOptions, operationsByTag as Operations, PAGINATION_DEFAULT_OFFSET, PAGINATION_DEFAULT_SIZE, PAGINATION_MAX_OFFSET, PAGINATION_MAX_SIZE, Page, Paginable, PaginationQueryMeta, PreviewBranchSchemaEditError, PreviewBranchSchemaEditPathParams, PreviewBranchSchemaEditRequestBody, PreviewBranchSchemaEditResponse, PreviewBranchSchemaEditVariables, Query, QueryMigrationRequestsError, QueryMigrationRequestsPathParams, QueryMigrationRequestsRequestBody, QueryMigrationRequestsResponse, QueryMigrationRequestsVariables, QueryTableError, QueryTablePathParams, QueryTableRequestBody, QueryTableVariables, RecordArray, RemoveGitBranchesEntryError, RemoveGitBranchesEntryPathParams, RemoveGitBranchesEntryQueryParams, RemoveGitBranchesEntryVariables, RemoveWorkspaceMemberError, RemoveWorkspaceMemberPathParams, RemoveWorkspaceMemberVariables, Repository, ResendWorkspaceMemberInviteError, ResendWorkspaceMemberInvitePathParams, ResendWorkspaceMemberInviteVariables, ResolveBranchError, ResolveBranchPathParams, ResolveBranchQueryParams, ResolveBranchResponse, ResolveBranchVariables, responses as Responses, RestRepository, SchemaDefinition, SchemaInference, SchemaPlugin, SchemaPluginResult, schemas as Schemas, SearchBranchError, SearchBranchPathParams, SearchBranchRequestBody, SearchBranchVariables, SearchOptions, SearchPlugin, SearchPluginResult, SearchTableError, SearchTablePathParams, SearchTableRequestBody, SearchTableVariables, SearchXataRecord, SelectableColumn, SelectedPick, Serializer, SetTableSchemaError, SetTableSchemaPathParams, SetTableSchemaRequestBody, SetTableSchemaVariables, SimpleCache, SimpleCacheOptions, SummarizeTableError, SummarizeTablePathParams, SummarizeTableRequestBody, SummarizeTableVariables, UpdateBranchMetadataError, UpdateBranchMetadataPathParams, UpdateBranchMetadataVariables, UpdateBranchSchemaError, UpdateBranchSchemaPathParams, UpdateBranchSchemaVariables, UpdateColumnError, UpdateColumnPathParams, UpdateColumnRequestBody, UpdateColumnVariables, UpdateDatabaseMetadataError, UpdateDatabaseMetadataPathParams, UpdateDatabaseMetadataRequestBody, UpdateDatabaseMetadataVariables, UpdateMigrationRequestError, UpdateMigrationRequestPathParams, UpdateMigrationRequestRequestBody, UpdateMigrationRequestVariables, UpdateRecordWithIDError, UpdateRecordWithIDPathParams, UpdateRecordWithIDQueryParams, UpdateRecordWithIDVariables, UpdateTableError, UpdateTablePathParams, UpdateTableRequestBody, UpdateTableVariables, UpdateUserError, UpdateUserVariables, UpdateWorkspaceError, UpdateWorkspaceMemberInviteError, UpdateWorkspaceMemberInvitePathParams, UpdateWorkspaceMemberInviteRequestBody, UpdateWorkspaceMemberInviteVariables, UpdateWorkspaceMemberRoleError, UpdateWorkspaceMemberRolePathParams, UpdateWorkspaceMemberRoleRequestBody, UpdateWorkspaceMemberRoleVariables, UpdateWorkspacePathParams, UpdateWorkspaceVariables, UpsertRecordWithIDError, UpsertRecordWithIDPathParams, UpsertRecordWithIDQueryParams, UpsertRecordWithIDVariables, ValueAtColumn, XataApiClient, XataApiClientOptions, XataApiPlugin, XataError, XataPlugin, XataPluginOptions, XataRecord, acceptWorkspaceMemberInvite, addGitBranchesEntry, addTableColumn, aggregateTable, applyBranchSchemaEdit, branchTransaction, buildClient, buildWorkerRunner, bulkInsertTableRecords, cancelWorkspaceMemberInvite, compareBranchSchemas, compareBranchWithUserSchema, compareMigrationRequest, contains, createBranch, createDatabase, createMigrationRequest, createTable, createUserAPIKey, createWorkspace, dEPRECATEDcreateDatabase, dEPRECATEDdeleteDatabase, dEPRECATEDgetDatabaseList, dEPRECATEDgetDatabaseMetadata, dEPRECATEDupdateDatabaseMetadata, deleteBranch, deleteColumn, deleteDatabase, deleteRecord, deleteTable, deleteUser, deleteUserAPIKey, deleteWorkspace, deserialize, endsWith, equals, executeBranchMigrationPlan, exists, ge, getAPIKey, getBranchDetails, getBranchList, getBranchMetadata, getBranchMigrationHistory, getBranchMigrationPlan, getBranchSchemaHistory, getBranchStats, getColumn, getCurrentBranchDetails, getCurrentBranchName, getDatabaseList, getDatabaseMetadata, getDatabaseURL, getGitBranchesMapping, getHostUrl, getMigrationRequest, getMigrationRequestIsMerged, getRecord, getTableColumns, getTableSchema, getUser, getUserAPIKeys, getWorkspace, getWorkspaceMembersList, getWorkspacesList, greaterEquals, greaterThan, greaterThanEquals, gt, gte, includes, includesAll, includesAny, includesNone, insertRecord, insertRecordWithID, inviteWorkspaceMember, is, isCursorPaginationOptions, isHostProviderAlias, isHostProviderBuilder, isIdentifiable, isNot, isXataRecord, le, lessEquals, lessThan, lessThanEquals, listMigrationRequestsCommits, listRegions, lt, lte, mergeMigrationRequest, notExists, operationsByTag, parseProviderString, parseWorkspacesUrlParts, pattern, previewBranchSchemaEdit, queryMigrationRequests, queryTable, removeGitBranchesEntry, removeWorkspaceMember, resendWorkspaceMemberInvite, resolveBranch, searchBranch, searchTable, serialize, setTableSchema, startsWith, summarizeTable, updateBranchMetadata, updateBranchSchema, updateColumn, updateDatabaseMetadata, updateMigrationRequest, updateRecordWithID, updateTable, updateUser, updateWorkspace, updateWorkspaceMemberInvite, updateWorkspaceMemberRole, upsertRecordWithID };
